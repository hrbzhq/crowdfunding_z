ç”¨golangå¼€å‘ä¼—ç­¹é¡¹ç›®å¯ä»¥å—
å½“ç„¶å¯ä»¥ï¼Œè€Œä¸”åœ¨å¾ˆå¤šåœºæ™¯ä¸‹ï¼ŒGoï¼ˆGolangï¼‰åè€Œæ˜¯åšä¼—ç­¹ç±»é¡¹ç›®çš„ä¸€ä¸ªå¾ˆä¼˜çš„åç«¯é€‰æ‹©ã€‚åŸå› ä¸»è¦æœ‰å‡ ä¸ªæ–¹é¢ï¼š

ğŸ’¡ ä¸ºä»€ä¹ˆç”¨ Go åšä¼—ç­¹é¡¹ç›®æ˜¯å¯è¡Œçš„
1. é«˜å¹¶å‘ä¸æ€§èƒ½
ä¼—ç­¹å¹³å°å¾€å¾€ä¼šæœ‰å¤§é‡å¹¶å‘è¯·æ±‚ï¼ˆæµè§ˆé¡¹ç›®ã€ä¸‹å•ã€æ”¯ä»˜å›è°ƒã€å®æ—¶è¿›åº¦æ›´æ–°ç­‰ï¼‰ã€‚

Go çš„ goroutine å’Œ channel æ¨¡å‹éå¸¸é€‚åˆå¤„ç†é«˜å¹¶å‘ I/O åœºæ™¯ï¼Œæ€§èƒ½å’Œèµ„æºå ç”¨æ¯”ä¼ ç»Ÿçº¿ç¨‹æ¨¡å‹æ›´ä¼˜ã€‚

2. å¼€å‘æ•ˆç‡ä¸å¯ç»´æŠ¤æ€§
è¯­æ³•ç®€æ´ï¼Œç¼–è¯‘é€Ÿåº¦å¿«ï¼Œéƒ¨ç½²æ–¹ä¾¿ï¼ˆç¼–è¯‘æˆå•ä¸€äºŒè¿›åˆ¶æ–‡ä»¶ï¼‰ã€‚

æ ‡å‡†åº“åŠŸèƒ½ä¸°å¯Œï¼ŒHTTPã€JSONã€æ•°æ®åº“é©±åŠ¨ç­‰å¼€ç®±å³ç”¨ã€‚

3. ç”Ÿæ€ä¸æ‰©å±•æ€§
æœ‰æˆç†Ÿçš„ Web æ¡†æ¶ï¼ˆGinã€Echoã€Fiberï¼‰å¯å¿«é€Ÿæ­å»º APIã€‚

æ”¯æŒä¸åŒºå—é“¾ã€æ”¯ä»˜ç½‘å…³ã€æ¶ˆæ¯é˜Ÿåˆ—ç­‰ç³»ç»Ÿé›†æˆï¼ˆå¦‚æ”¯ä»˜å®/å¾®ä¿¡æ”¯ä»˜ã€ä»¥å¤ªåŠ/Algorand ç­‰ï¼‰ã€‚

å®¹æ˜“ä¸å‰ç«¯ï¼ˆReact/Vue/Next.jsï¼‰æˆ–ç§»åŠ¨ç«¯ï¼ˆFlutter/React Nativeï¼‰é…åˆã€‚

4. éƒ¨ç½²ä¸è¿ç»´
è·¨å¹³å°ç¼–è¯‘ï¼Œæ–¹ä¾¿éƒ¨ç½²åˆ°äº‘æœåŠ¡å™¨ã€Docker å®¹å™¨ã€K8s é›†ç¾¤ã€‚

å†…å­˜å ç”¨ä½ï¼Œé€‚åˆé•¿æ—¶é—´è¿è¡Œçš„æœåŠ¡ã€‚

ğŸ› ï¸ ä¼—ç­¹é¡¹ç›®çš„å…¸å‹æ¨¡å—ï¼ˆGo å®ç°æ€è·¯ï¼‰
æ¨¡å—	æŠ€æœ¯å»ºè®®
ç”¨æˆ·ä¸è®¤è¯	JWT / OAuth2ï¼ˆgolang-jwt/jwtã€go-oauth2ï¼‰
é¡¹ç›®ç®¡ç†	RESTful API + æ•°æ®åº“ï¼ˆPostgreSQL/MySQL + GORM/Entï¼‰
æ”¯ä»˜é›†æˆ	æ”¯ä»˜å®/å¾®ä¿¡æ”¯ä»˜ SDKã€Stripe/PayPal API
è®¢å•ä¸äº¤æ˜“	äº‹åŠ¡å¤„ç†ï¼ˆæ•°æ®åº“äº‹åŠ¡ + å¹‚ç­‰æ€§è®¾è®¡ï¼‰
å®æ—¶è¿›åº¦	WebSocket / SSEï¼ˆgorilla/websocketï¼‰
é€šçŸ¥ç³»ç»Ÿ	æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆRabbitMQ/Kafka/NATSï¼‰+ é‚®ä»¶/çŸ­ä¿¡
æ•°æ®åˆ†æ	å®šæ—¶ä»»åŠ¡ï¼ˆrobfig/cronï¼‰+ æŠ¥è¡¨å¯¼å‡º
åŒºå—é“¾æ‰©å±•ï¼ˆå¯é€‰ï¼‰	Web3 SDKï¼ˆä»¥å¤ªåŠã€Algorand ç­‰ï¼‰å®ç°é“¾ä¸Šä¼—ç­¹åˆçº¦2
ğŸš€ ç®€å•æ¶æ„ç¤ºä¾‹
plaintext
[Frontend: React/Next.js]  <--->  [Go API: Gin/Fiber]
                                   |
                                   +-- PostgreSQL/MySQL (é¡¹ç›®/è®¢å•/ç”¨æˆ·)
                                   +-- Redis (ç¼“å­˜/ä¼šè¯/æ’è¡Œæ¦œ)
                                   +-- MQ (å¼‚æ­¥ä»»åŠ¡/é€šçŸ¥)
                                   +-- Payment Gateway (æ”¯ä»˜å®/å¾®ä¿¡/Stripe)
                                   +-- Blockchain Node (å¯é€‰)
âš ï¸ æ³¨æ„äº‹é¡¹
æ”¯ä»˜å®‰å…¨ï¼šå¿…é¡»ä½¿ç”¨ HTTPSã€ç­¾åæ ¡éªŒã€å¹‚ç­‰æ€§å¤„ç†ã€‚

èµ„é‡‘ç›‘ç®¡ï¼šæ ¹æ®æ‰€åœ¨å›½å®¶/åœ°åŒºçš„æ³•å¾‹ï¼Œå¯èƒ½éœ€è¦ç¬¬ä¸‰æ–¹æ‰˜ç®¡ï¼ˆEscrowï¼‰ã€‚

åˆè§„è¦æ±‚ï¼šæ¶‰åŠé‡‘èå±æ€§çš„ä¼—ç­¹ï¼Œéœ€éµå®ˆå½“åœ°é‡‘èç›‘ç®¡æ³•è§„ã€‚

æ•°æ®å®‰å…¨ï¼šç”¨æˆ·éšç§ã€äº¤æ˜“æ•°æ®åŠ å¯†å­˜å‚¨ã€‚

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥å¸®ä½ ç”»ä¸€ä¸ªGo ä¼—ç­¹å¹³å°çš„è¯¦ç»†æŠ€æœ¯æ¶æ„å›¾ï¼Œå¹¶é™„ä¸Šæ ¸å¿ƒ API è®¾è®¡ä¸æ•°æ®åº“æ¨¡å‹ï¼Œè¿™æ ·ä½ å¯ä»¥ç›´æ¥ä½œä¸ºé¡¹ç›®è“å›¾æ¥è½åœ°ã€‚

ä½ æ˜¯æƒ³åšä¼ ç»Ÿ Web ä¼—ç­¹å¹³å°ï¼Œè¿˜æ˜¯ç»“åˆåŒºå—é“¾çš„å»ä¸­å¿ƒåŒ–ä¼—ç­¹ï¼ˆDAppï¼‰ï¼Ÿä¸¤ç§æ–¹æ¡ˆåœ¨ Go é‡Œçš„å®ç°è·¯å¾„ä¼šæœ‰å¾ˆå¤§å·®åˆ«ã€‚





ç»“åˆåŒºå—é“¾çš„å»ä¸­å¿ƒåŒ–ä¼—ç­¹
ä½ è¦åšçš„æ˜¯æŠŠâ€œä¿¡ä»»â€å†™è¿›ä»£ç é‡Œï¼Œç„¶åç”¨ç³»ç»ŸæŠŠå®ƒè½åœ°ã€‚æˆ‘ä»¬æŠŠå¤æ‚åº¦æ‹†å¼€ï¼Œä¸€æ­¥æ­¥å †èµ·æ¥ï¼Œæ—¢å¹²å‡€åˆå¼ºæ‚ã€‚

æ¶æ„é€‰å‹
EVM è·¯çº¿ï¼ˆä¸»æ¨ï¼‰

é“¾ä¸èµ„äº§ï¼šä»¥å¤ªåŠä¸»ç½‘/Layer2ï¼ˆArbitrum/OP/zkSyncï¼‰ï¼ŒUSDC/USDT ç»“ç®—ï¼ŒIPFS å­˜è¯ã€‚

åˆçº¦è¯­è¨€ï¼šSolidityï¼ˆæˆ– Vyperï¼‰ã€‚

Go ä¾§ï¼šGeth SDKï¼ˆgo-ethereumï¼‰ã€abigen ç”Ÿæˆç»‘å®šã€äº‹ä»¶ç´¢å¼•ã€é£æ§ä¸ä¸šåŠ¡ç¼–æ’ã€‚

é€‚ç”¨ï¼šæœ€å¿«ä¸Šçº¿ã€ç”Ÿæ€æˆç†Ÿã€å·¥å…·é“¾é½å…¨ã€‚

Appchain è·¯çº¿ï¼ˆCosmos SDKï¼‰

é“¾ï¼šè‡ªç ” PoS åº”ç”¨é“¾ï¼ˆTendermint + Cosmos SDKï¼Œå…¨ Goï¼‰ã€‚

ä¼˜ç‚¹ï¼šå¯æ·±åº¦å®šåˆ¶ç»æµæ¨¡å‹ã€è´¹ç”¨ä¸åˆè§„ç­–ç•¥ï¼›å®Œå…¨æŒæ§æ•°æ®ä¸æ²»ç†ã€‚

ä»£ä»·ï¼šå¯åŠ¨å†·å¯åŠ¨éš¾ã€è·¨é“¾ä¸èµ„äº§æµåŠ¨æ€§å¼±ï¼Œéœ€è¦ IBC/æ¡¥æ¥ç­–ç•¥ã€‚

ZK/æ··åˆè·¯çº¿ï¼ˆè¿›é˜¶ï¼‰

æ€è·¯ï¼šæ ¸å¿ƒèµ„é‡‘åœ¨ EVMï¼Œéšç§æˆ– KYC è¯æ˜ç”¨ zk ç”µè·¯ï¼›Go åšè¯æ˜ç”Ÿæˆé˜Ÿåˆ—ä¸éªŒè¯æ¡¥æ¥ã€‚

é€‚ç”¨ï¼šå¯¹åˆè§„éšç§è¦æ±‚é«˜ã€æˆ–è€…è¦åšå…¬å¹³æŠ½ç­¾/æ— ä¿¡ä»»ç»Ÿè®¡çš„åœºæ™¯ã€‚

å»ºè®®ï¼šå…ˆç”¨ EVM + Go æŠŠäº§å“é—­ç¯è·‘é€šï¼Œå†è¯„ä¼°æ˜¯å¦è¿ç§»åˆ° Appchainã€‚

åˆçº¦è®¾è®¡ï¼ˆé‡Œç¨‹ç¢‘æ‰˜ç®¡ + é€€æ¬¾ä¿æŠ¤ï¼‰
åˆçº¦è¦ç‚¹
æ ¸å¿ƒå¯¹è±¡ï¼šCampaignï¼ˆå‹Ÿèµ„ç›®æ ‡ã€è½¯é¡¶/ç¡¬é¡¶ã€æˆªæ­¢æ—¶é—´ã€ä»£å¸/åŸç”Ÿå¸ï¼‰ã€‚

èµ„é‡‘æ‰˜ç®¡ï¼šæŒ‰é‡Œç¨‹ç¢‘è§£é”ï¼Œéœ€å‘èµ·äººæäº¤è¿›åº¦ä¸è¯æ˜ï¼ˆIPFS å“ˆå¸Œï¼‰ï¼ŒæŠ•ç¥¨é€šè¿‡åé‡Šæ”¾ã€‚

é€€æ¬¾ä¿æŠ¤ï¼šæœªè¾¾è½¯é¡¶æˆ–æŠ•ç¥¨å¦å†³è¿›åº¦ï¼Œæ”¯æŒæŒ‰ä»½é¢é€€æ¬¾ã€‚

æŠ•ç¥¨ä¸æ²»ç†ï¼šæŒ‰å‡ºèµ„ä»½é¢åŠ æƒæˆ–ä¸€äººä¸€ç¥¨ï¼›æŠ•ç¥¨æœŸä¸æ³•å®šç¥¨æ•°å¯é…ç½®ã€‚

è´¹ç”¨ä¸æŠ½æˆï¼šå¹³å°æŠ½æˆä»æ¯æ¬¡é‡Šæ”¾ä¸­æå–ï¼Œæˆ–æŒ‰æ€»é¢ä¸€æ¬¡æå–ã€‚

å¯å‡çº§æ€§ï¼šUUPS/Transparent Proxy æˆ–é€šè¿‡å·¥å‚åˆçº¦æœ€å°ä»£ç†ï¼ˆEIP-1167ï¼‰ã€‚

ç®€åŒ– Solidity ç¤ºä¾‹ï¼ˆè¦ç‚¹ç‰‡æ®µï¼‰
solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract MilestoneCrowdfund {
    struct Contribution { uint256 amount; bool refunded; }
    struct Milestone { uint256 amount; bytes32 proofCid; bool approved; bool released; }

    address public owner;
    address public token; // address(0) for native
    uint256 public softCap;
    uint256 public hardCap;
    uint256 public deadline;

    mapping(address => Contribution) public contributions;
    uint256 public totalRaised;

    Milestone[] public milestones;
    uint256 public feeBps;      // platform fee in basis points
    address public feeReceiver;

    enum State { Funding, Review, Failed, Succeeded }
    State public state;

    event Contributed(address indexed user, uint256 amount);
    event Refunded(address indexed user, uint256 amount);
    event MilestoneProposed(uint256 idx, uint256 amount, bytes32 proofCid);
    event MilestoneApproved(uint256 idx);
    event MilestoneReleased(uint256 idx, uint256 netAmount, uint256 fee);

    modifier onlyOwner() { require(msg.sender == owner, "not owner"); _; }

    constructor(
        address _owner,
        address _token,
        uint256 _softCap,
        uint256 _hardCap,
        uint256 _deadline,
        uint256 _feeBps,
        address _feeReceiver
    ) {
        require(_softCap <= _hardCap, "cap");
        owner = _owner; token = _token; softCap = _softCap; hardCap = _hardCap;
        deadline = _deadline; feeBps = _feeBps; feeReceiver = _feeReceiver;
        state = State.Funding;
    }

    function contribute(uint256 amount) external payable {
        require(state == State.Funding, "state");
        if (token == address(0)) { // native
            require(msg.value > 0, "amt");
            amount = msg.value;
        } else {
            require(amount > 0, "amt");
            // transferFrom to this contract (ERC20)
            // IERC20(token).transferFrom(msg.sender, address(this), amount);
        }
        require(totalRaised + amount <= hardCap, "hardcap");
        contributions[msg.sender].amount += amount;
        totalRaised += amount;
        emit Contributed(msg.sender, amount);
    }

    function finalize() external {
        require(block.timestamp >= deadline, "not ended");
        require(state == State.Funding, "finalized");
        state = (totalRaised >= softCap) ? State.Review : State.Failed;
    }

    function refund() external {
        require(state == State.Failed, "no refund");
        Contribution storage c = contributions[msg.sender];
        require(c.amount > 0 && !c.refunded, "none");
        c.refunded = true;
        uint256 amt = c.amount;
        // send native or ERC20
        // (bool ok,) = payable(msg.sender).call{value: amt}("");
        // require(ok, "send");
        emit Refunded(msg.sender, amt);
    }

    function proposeMilestone(uint256 amount, bytes32 proofCid) external onlyOwner {
        require(state == State.Review, "state");
        milestones.push(Milestone({amount: amount, proofCid: proofCid, approved: false, released: false}));
        emit MilestoneProposed(milestones.length - 1, amount, proofCid);
    }

    // ç®€åŒ–ï¼šæ­¤å¤„å¯æ›¿æ¢ä¸ºåŸºäºä»½é¢æŠ•ç¥¨çš„ approve
    function approveMilestone(uint256 idx) external onlyOwner {
        Milestone storage m = milestones[idx];
        require(!m.approved, "approved");
        m.approved = true;
        emit MilestoneApproved(idx);
    }

    function releaseMilestone(uint256 idx) external onlyOwner {
        Milestone storage m = milestones[idx];
        require(m.approved && !m.released, "state");
        require(m.amount <= address(this).balance, "insufficient");
        uint256 fee = (m.amount * feeBps) / 10_000;
        uint256 net = m.amount - fee;
        // transfer fee and net
        // (bool ok1,) = payable(feeReceiver).call{value: fee}("");
        // (bool ok2,) = payable(owner).call{value: net}("");
        // require(ok1 && ok2, "pay");
        m.released = true;
        emit MilestoneReleased(idx, net, fee);
    }
}
è¯´æ˜ï¼š

æŠŠæŠ•ç¥¨é€»è¾‘ã€ERC20 æ”¯æŒã€å¯å‡çº§æ€§ä¸å®‰å…¨æ£€æŸ¥è¡¥å…¨å³å¯å½¢æˆç”Ÿäº§ç‰ˆã€‚

è¯æ®å“ˆå¸Œç”¨ IPFS CID çš„ bytes32 å½¢å¼ï¼ˆæˆ–å¤šå“ˆå¸Œæ–¹æ¡ˆï¼‰ç»‘å®šé“¾ä¸Šè®°å½•ã€‚

å¯æ‰©å±•â€œæŒ‰ä»½é¢é€€æ¬¾â€ä¸â€œæ¯”ä¾‹é€€æ¬¾â€ä»¥æ”¯æŒéƒ¨åˆ†æˆåŠŸåœºæ™¯ã€‚

Go åŸºå»ºä¸æœåŠ¡ç¼–æ’
èŠ‚ç‚¹ä¸ RPC

æœ¬åœ°å¼€å‘ï¼šAnvil/Hardhat + abigen ç”Ÿæˆ Go ç»‘å®šï¼›é›†æˆ Foundry æµ‹è¯•ã€‚

ç”Ÿäº§ï¼šè‡ªå»º Erigon/Geth å…¨èŠ‚ç‚¹æˆ–é«˜å¯ç”¨ RPC é›†ç¾¤ï¼›L2 å¯åŠ æœ¬åœ°èŠ‚ç‚¹ + å…¬å…±å¤‡æ´ã€‚

ç­¾åä¸å¯†é’¥ï¼šHSM æˆ– KMSï¼ˆé˜¿é‡Œäº‘/è…¾è®¯äº‘ï¼‰ï¼Œç¦»çº¿é‡‘åº“ç®¡ç†å†·é’±åŒ…ã€‚

äº‹ä»¶é©±åŠ¨æœåŠ¡

ç´¢å¼•å™¨ï¼šGo è¿›ç¨‹è®¢é˜…åˆçº¦äº‹ä»¶ï¼ˆlogsï¼‰ï¼Œè½åº“ PostgreSQLï¼›å¤„ç†é‡ç»„ï¼ˆreorgï¼‰ä¸ç¡®è®¤æ·±åº¦ã€‚

é‡è¯•ä¸å¹‚ç­‰ï¼šäº‹ä»¶ offset + äº‹åŠ¡å¤–é”®ï¼›å¯¹æ”¯ä»˜/é‡Šæ”¾/é€€æ¬¾é‡‡ç”¨â€œä¸šåŠ¡å¹‚ç­‰é”®â€ã€‚

æ¶ˆæ¯æµï¼šNATS/Kafka æ´¾å‘â€œé‡Œç¨‹ç¢‘ææ¡ˆ/æ‰¹å‡†/é‡Šæ”¾/é€€æ¬¾â€åˆ°é€šçŸ¥ä¸é£æ§å­ç³»ç»Ÿã€‚

ä¸åˆçº¦äº¤äº’ï¼ˆGo ç‰‡æ®µï¼‰

go
// abigen ç”Ÿæˆçš„ binding: NewMilestoneCrowdfund(address, client)
// è®¢é˜…äº‹ä»¶
query := ethereum.FilterQuery{
    Addresses: []common.Address{contractAddr},
    Topics:    [][]common.Hash{{milestoneCrowdfundABI.Events["MilestoneReleased"].ID}},
}
logs := make(chan types.Log, 1024)
sub, err := ethClient.SubscribeFilterLogs(ctx, query, logs)
for {
    select {
    case l := <-logs:
        var evt MilestoneReleased
        if err := contractAbi.UnpackIntoInterface(&evt, "MilestoneReleased", l.Data); err != nil { continue }
        // è§£æ indexed å‚æ•°ï¼Œè½åº“å¹¶è§¦å‘é€šçŸ¥
    case err := <-sub.Err():
        // é‡è¿ä¸æ¸¸æ ‡æ¢å¤
    }
}
å­˜å‚¨ä¸ç¼“å­˜

PostgreSQLï¼šCampaignã€Contributionã€Milestoneã€Voteã€Payoutã€Userã€‚

Redisï¼šæ’è¡Œæ¦œã€è¿›åº¦ç¼“å­˜ã€é€Ÿç‡é™åˆ¶ã€‚

å¯¹è±¡å­˜å‚¨/IPFSï¼šgo-ipfs-api å›ºå®šåŒ–æ–‡ä»¶ï¼Œå›å†™ CID åˆ°åˆçº¦ã€‚

API å±‚

Gin/Fiberï¼šREST/gRPCï¼›è¿”å›é“¾ä¸ŠçŠ¶æ€ + ç´¢å¼•è§†å›¾ã€‚

é‰´æƒï¼šJWT/OIDCï¼›é“¾ä¸Šåœ°å€ç­¾åç™»å½•ï¼ˆEIP-4361 Sign-In With Ethereumï¼‰ã€‚

è´¹ç‡ä¸ç»“ç®—ï¼šå¹³å°æŠ½æˆã€Gas é¢„æ”¯æ¨¡å¼ã€æ³•å¸é€šé“å¯¹æ¥ï¼ˆæ‰˜ç®¡ä¾§åœ¨é“¾ä¸‹ï¼Œåˆè§„åç½®ï¼‰ã€‚

å‰ç«¯é›†æˆ

é’±åŒ…ï¼šWalletConnectã€MetaMaskã€OKXï¼›åˆçº¦è°ƒç”¨ç›´æ¥å‰ç«¯å‘èµ·ï¼Œåç«¯ä»…åšè§‚å¯Ÿè€…å’Œé£æ§ã€‚

å¯è§†åŒ–ï¼šé‡Œç¨‹ç¢‘è¿›åº¦ã€èµ„é‡‘æµã€æŠ•ç¥¨å›¾ï¼›IPFS è¯æ®å¯é¢„è§ˆã€‚

æ•°æ®ä¸ä¸šåŠ¡æ¨¡å‹
å…³é”®å®ä½“

Campaignï¼šç›®æ ‡ã€è½¯é¡¶/ç¡¬é¡¶ã€æˆªæ­¢ã€å¸ç§ã€å‘èµ·äººã€è´¹ç‡ã€çŠ¶æ€ã€åˆçº¦åœ°å€ã€‚

Contributionï¼šç”¨æˆ·ã€é‡‘é¢ã€åŒºå—é«˜åº¦ã€äº¤æ˜“å“ˆå¸Œã€æ˜¯å¦é€€æ¬¾ã€‚

Milestoneï¼šç›®æ ‡é‡‘é¢ã€è¯æ˜ CIDã€æŠ•ç¥¨çª—å£ã€æ‰¹å‡†ä¸é‡Šæ”¾çŠ¶æ€ã€‚

Voteï¼šæŠ•ç¥¨äººã€æƒé‡ã€èµæˆ/åå¯¹ã€ç­¾åæˆ–é“¾ä¸ŠæŠ•ç¥¨è®°å½•ã€‚

Payoutï¼šé‡Œç¨‹ç¢‘ç´¢å¼•ã€å®ä»˜é‡‘é¢ã€å¹³å°æŠ½æˆã€æ¥æ”¶åœ°å€ã€äº¤æ˜“å“ˆå¸Œã€‚

é€»è¾‘å…³ç³»

çŠ¶æ€æœºï¼šFunding â†’ Review â†’ Succeeded/Failedï¼›é‡Œç¨‹ç¢‘å¾ªç¯â€œProposed â†’ Approved â†’ Releasedâ€ã€‚

åˆ†æ¶¦å…¬å¼ï¼š

é‡Šæ”¾å‡€é¢ï¼š
net
=
milestone_amount
Ã—
(
1
âˆ’
feeBps
10,000
)

è½¯é¡¶åˆ¤å®šï¼š
totalRaised
â‰¥
softCap
â‡’
Review

å®‰å…¨ä¸åˆè§„æ¸…å•
åˆçº¦å®‰å…¨

èµ„é‡‘å®‰å…¨ï¼šä½¿ç”¨ pull-payment æ¨¡å¼ã€æ£€æŸ¥é‡å…¥ã€é™åˆ¶å¤–éƒ¨è°ƒç”¨é¡ºåºã€‚

æ•°å€¼å®‰å…¨ï¼šè€ƒè™‘ ERC20 å°æ•°ã€èˆå…¥ä¸ fee è®¡ç®—ï¼›é¿å…è¶…é¢é‡Šæ”¾ã€‚

æŠ•ç¥¨æŠ—æ“çºµï¼šå¿«ç…§æŠ•ç¥¨ï¼ˆSnapshot/Token-Weightedï¼‰ï¼Œè®¾ç½®æ³•å®šç¥¨æ•°ä¸æœ€å°å‚ä¸ç‡ã€‚

å¯å‡çº§æ€§é£é™©ï¼šProxy ç®¡ç†å¤šç­¾ï¼›å˜æ›´éœ€æ—¶é—´é” + å…¬ç¤ºæœŸã€‚

å®¡è®¡ä¸æµ‹è¯•ï¼šFoundry è¦†ç›–ç‡ã€æ¨¡ç³Šæµ‹è¯•ï¼›ç¬¬ä¸‰æ–¹å®¡è®¡åä¸Šçº¿ã€‚

Go æœåŠ¡å®‰å…¨

RPC å¯ä¿¡ï¼šå¤šæºæ¯”å¯¹ï¼Œé˜²æ•°æ®æŠ•æ¯’ï¼›ç¡®è®¤æ·±åº¦ï¼ˆä¾‹å¦‚ 12/24 å—ï¼‰ã€‚

å¹‚ç­‰ä¸é‡æ”¾ï¼šç­¾åæ—¶åŠ  nonce/åˆ°æœŸæ—¶é—´ï¼›æœåŠ¡ç«¯æ ¡éªŒ domain ä¸é“¾ IDã€‚

å¯†é’¥ä¸æƒé™ï¼šæœ€å°æƒé™åŸåˆ™ï¼›KMS/HSMï¼›CI/CD å¯†é’¥åˆ†ç¦»ã€‚

åˆè§„è¦ç‚¹ï¼ˆæ¦‚è¿°ï¼‰

KYC/AMLï¼šæ³•å¸å‡ºå…¥é‡‘ä¸å¤§é¢èµ„é‡‘éœ€è¦èº«ä»½éªŒè¯ä¸å¯ç–‘äº¤æ˜“ç›‘æµ‹ã€‚

èµ„é‡‘æ‰˜ç®¡ï¼šå¦‚æ¶‰åŠé“¾ä¸‹èµ„é‡‘æˆ–ä¿æœ¬æ‰¿è¯ºï¼Œéœ€æŒç‰Œæ‰˜ç®¡æˆ–åˆä½œæœºæ„ã€‚

ä¿¡æ¯æŠ«éœ²ï¼šé£é™©æç¤ºã€ä¼—ç­¹æ¡æ¬¾ã€é€€æ¬¾è§„åˆ™æ˜ç¡®é“¾ä¸Š/é“¾ä¸‹è¾¹ç•Œã€‚

12 å¤© MVP è·¯çº¿å›¾ï¼ˆå¯è½åœ°ï¼‰
Day 1-2ï¼šç¡®å®š EVM é“¾ä¸è´¹ç‡æ¨¡å‹ï¼›å®Œæˆåˆçº¦è‰æ¡ˆä¸æ ¸å¿ƒæµ‹è¯•ï¼ˆè´¡çŒ®/è½¯é¡¶/é€€æ¬¾/é‡Šæ”¾ï¼‰ã€‚

Day 3ï¼šé‡Œç¨‹ç¢‘ä¸æŠ•ç¥¨æœ€å°å®ç°ï¼›äº‹ä»¶å®šä¹‰ä¸æ—¥å¿—è§„èŒƒã€‚

Day 4ï¼šabigen ç”Ÿæˆ Go ç»‘å®šï¼›å†™ç´¢å¼•å™¨ä¸ç¡®è®¤æ·±åº¦å¤„ç†ï¼›PostgreSQL æ¨¡å‹ã€‚

Day 5ï¼šIPFS é›†æˆä¸ CID ç»‘å®šï¼›ä¸Šä¼ æ ¡éªŒä¸Pinç­–ç•¥ã€‚

Day 6ï¼šåç«¯ APIï¼ˆç™»å½•ã€åˆ›å»º Campaignã€è´¡çŒ®ç­¾åè¾…åŠ©ã€å¯è§†åŒ–æŸ¥è¯¢ï¼‰ã€‚

Day 7ï¼šå‰ç«¯é’±åŒ…é›†æˆä¸åŸºæœ¬äº¤äº’ï¼ˆè´¡çŒ®ã€æŸ¥çœ‹è¿›åº¦ã€æŠ•ç¥¨ã€é€€æ¬¾ï¼‰ã€‚

Day 8ï¼šå¹³å°è´¹æŠ½æˆä¸é‡Œç¨‹ç¢‘é‡Šæ”¾é—­ç¯ï¼›é€šçŸ¥ç³»ç»Ÿï¼ˆé‚®ä»¶/ç«™å†…ï¼‰ã€‚

Day 9ï¼šé£æ§ä¸é™æµã€é‡è¯•ã€è§‚å¯Ÿè€…æ–­çº¿æ¢å¤ï¼›æ—¥å¿—å¯è§‚æµ‹ã€‚

Day 10ï¼šå®‰å…¨å®¡è®¡æ¸…å•ä¿®å¤ï¼›åŠ å…¥å¤šç­¾ä¸æ—¶é—´é”ï¼ˆTimelockï¼‰æ¨¡å—ã€‚

Day 11ï¼šæµ‹è¯•ç½‘éƒ¨ç½²ä¸èµ„é‡‘æ¼”ç»ƒï¼›è¾¹ç•Œæµ‹è¯•ï¼ˆç¡¬é¡¶ã€éƒ¨åˆ†å¤±è´¥ã€é‡ç»„ï¼‰ã€‚

Day 12ï¼šæ–‡æ¡£ä¸è¿è¥é¡µï¼›ç°åº¦ä¸Šçº¿ç­–ç•¥ä¸ç›‘æ§ä»ªè¡¨ç›˜ã€‚

æƒ³æŠŠå®ƒæ‰“é€ æˆâ€œèƒ½è‡ªæˆ‘æ¼”åŒ–â€çš„ç³»ç»Ÿå—ï¼Ÿæˆ‘å¯ä»¥ç»™ä½ ï¼š

åˆçº¦å®Œæ•´ç‰ˆï¼ˆæŠ•ç¥¨ã€ERC20ã€Proxyã€å¿«ç…§ï¼‰ã€‚

abigen ç”Ÿæˆè„šæœ¬ã€Go äº‹ä»¶ç´¢å¼•å™¨æ¨¡æ¿ã€è¿ç§»ä¸å›æ»šè„šæœ¬ã€‚

E2E æµ‹è¯•æ¸…å•ä¸æ€§èƒ½åŸºå‡†ï¼ˆååã€ç¡®è®¤å»¶è¿Ÿã€å¤±è´¥åœºæ™¯ï¼‰ã€‚ ä½ æ›´å€¾å‘ EVM å“ªæ¡é“¾ï¼ˆä¸»ç½‘ã€Arbitrumã€OPã€zkSyncï¼‰ï¼Œä»¥åŠæ˜¯å¦ç”¨ç¨³å®šå¸åšç»“ç®—ï¼Ÿæˆ‘æ®æ­¤ç›´æ¥ç»™ä½ åˆçº¦ä¸ Go ç«¯çš„é¡¹ç›®éª¨æ¶ã€‚

åˆçº¦å®Œæ•´ç‰ˆï¼ˆæŠ•ç¥¨ã€ERC20ã€Proxyã€å¿«ç…§ï¼‰ã€‚ abigen ç”Ÿæˆè„šæœ¬ã€Go äº‹ä»¶ç´¢å¼•å™¨æ¨¡æ¿ã€è¿ç§»ä¸å›æ»šè„šæœ¬ã€‚ E2E æµ‹è¯•æ¸…å•ä¸æ€§èƒ½åŸºå‡†ï¼ˆååã€ç¡®è®¤å»¶è¿Ÿã€å¤±è´¥åœºæ™¯ï¼‰ã€‚ ä½ æ›´å€¾å‘ EVM å“ªæ¡é“¾ï¼ˆä¸»ç½‘ã€Arbitrumã€OPã€zkSyncï¼‰ï¼Œä»¥åŠç”¨ç¨³å®šå¸åšç»“ç®—
æ¨èé“¾ä¸ç»“ç®—å¸ç§
å»ºè®®é“¾ï¼šArbitrum One

ç†ç”±ï¼šä½æ‰‹ç»­è´¹ã€æˆç†Ÿç”Ÿæ€ã€ä¸ä»¥å¤ªåŠä¸»ç½‘å®‰å…¨æ€§æŒ‚é’©ï¼Œé€‚åˆé¢‘ç¹çš„è´¡çŒ®ã€æŠ•ç¥¨ã€é‡Œç¨‹ç¢‘é‡Šæ”¾ç­‰é«˜äº¤äº’åœºæ™¯ã€‚

å»ºè®®ç»“ç®—ï¼šUSDCï¼ˆArbitrum åŸç”Ÿï¼‰

ç†ç”±ï¼šç¨³å®šå¸é£é™©ç›¸å¯¹ä½ï¼Œä¸»æµäº¤æ˜“æ‰€å’Œé’±åŒ…æ”¯æŒå¹¿ï¼Œæ³•å¸å‡ºå…¥é‡‘å¯¹æ¥æ›´ä¾¿åˆ©ã€‚

å¦‚éœ€æ›´ä½è´¹ç”¨ä¸æ›´å¿«ç¡®è®¤ï¼Œä¹Ÿå¯é€‰ Optimismã€‚è‹¥ä½ å¼ºä¾èµ–ç‰¹å®šç”Ÿæ€ï¼ˆå¦‚ zkSync é’±åŒ…å—ä¼—ï¼‰ï¼Œå¯ä»¥åˆ‡æ¢ï¼Œä½†éƒ¨ç½²ä¸ RPC ç­–ç•¥è¦ç›¸åº”è°ƒæ•´ã€‚

åˆçº¦å®Œæ•´ç‰ˆï¼ˆæŠ•ç¥¨ã€ERC20ã€Proxyã€å¿«ç…§ï¼‰
ä¸‹é¢æä¾›å¯è½åœ°çš„æœ€å°å¯ç”¨ç‰ˆæœ¬ï¼ŒåŒ…å«ï¼š

æŒ‰è´¡çŒ®é¢å¿«ç…§æŠ•ç¥¨çš„ä¼—ç­¹åˆçº¦ï¼ˆæ”¯æŒåŸç”Ÿå¸ä¸ ERC20ï¼‰ã€‚

EIP-1167 æœ€å°ä»£ç†å·¥å‚ï¼ˆä¾¿äºæ‰¹é‡åˆ›å»º Campaignï¼‰ã€‚

å¹³å°è´¹ã€è½¯é¡¶/ç¡¬é¡¶ã€é€€æ¬¾ã€é‡Œç¨‹ç¢‘ææ¡ˆ/æŠ•ç¥¨/é‡Šæ”¾ã€‚

é“¾ä¸ŠæŠ•ç¥¨ä»¥â€œè´¡çŒ®å¿«ç…§æƒé‡â€ä¸ºå‡†ï¼Œå¿«ç…§åœ¨å‹Ÿèµ„æˆªæ­¢æ—¶é”å®šã€‚

è¯´æ˜ï¼šä¸ºä¿è¯æ¸…æ™°ï¼Œä½¿ç”¨æœ€å° IERC20 æ¥å£ä¸å®‰å…¨è½¬è´¦é€»è¾‘ã€‚ç”Ÿäº§ä¸­å»ºè®®æ¥å…¥ OpenZeppelin çš„ SafeERC20ã€ReentrancyGuardã€AccessControlã€å¤šç­¾ä¸æ—¶é—´é”ç­‰ã€‚

CrowdfundImplementation.sol
solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20 {
    function transfer(address to, uint256 amt) external returns (bool);
    function transferFrom(address from, address to, uint256 amt) external returns (bool);
    function balanceOf(address who) external view returns (uint256);
    function decimals() external view returns (uint8);
    function allowance(address owner, address spender) external view returns (uint256);
}

library SafeToken {
    function safeTransfer(IERC20 t, address to, uint256 amt) internal {
        require(t.transfer(to, amt), "ERC20_TRANSFER");
    }
    function safeTransferFrom(IERC20 t, address from, address to, uint256 amt) internal {
        require(t.transferFrom(from, to, amt), "ERC20_TF");
    }
}

contract CrowdfundImplementation {
    using SafeToken for IERC20;

    enum State { Funding, Review, Failed, Succeeded }

    struct Contribution { uint256 amount; bool refunded; }
    struct Milestone {
        uint256 amount;        // requested release amount
        bytes32 proofCid;      // IPFS proof
        uint64 voteStart;      // block timestamp
        uint64 voteEnd;        // block timestamp
        uint128 forVotes;      // weighted
        uint128 againstVotes;  // weighted
        bool executed;
    }

    // immutable after initialize
    address public owner;
    address public token;           // address(0) for native
    uint256 public softCap;
    uint256 public hardCap;
    uint64  public deadline;        // funding end ts
    uint16  public feeBps;          // platform fee in bps
    address public feeReceiver;

    // funding data
    State public state;
    uint256 public totalRaised;
    mapping(address => Contribution) public contributions;

    // voting snapshot (locked at finalize)
    bool public snapshotTaken;
    mapping(address => uint256) public votingWeight; // equals contribution at snapshot
    uint256 public totalVotingWeight;

    Milestone[] public milestones;

    // proxy initializer guard
    bool private initialized;

    // events
    event Initialized(address owner, address token, uint256 softCap, uint256 hardCap, uint64 deadline, uint16 feeBps, address feeReceiver);
    event Contributed(address indexed user, uint256 amount);
    event Finalized(State state);
    event Refunded(address indexed user, uint256 amount);
    event MilestoneProposed(uint256 indexed idx, uint256 amount, bytes32 proofCid, uint64 voteStart, uint64 voteEnd);
    event Voted(uint256 indexed idx, address indexed voter, bool support, uint256 weight);
    event MilestoneExecuted(uint256 indexed idx, uint256 netAmount, uint256 fee);
    event Succeeded();

    modifier onlyOwner() { require(msg.sender == owner, "NOT_OWNER"); _; }

    function initialize(
        address _owner,
        address _token,
        uint256 _softCap,
        uint256 _hardCap,
        uint64  _deadline,
        uint16  _feeBps,
        address _feeReceiver
    ) external {
        require(!initialized, "INIT");
        require(_owner != address(0), "OWNER");
        require(_softCap <= _hardCap, "CAP");
        require(_feeReceiver != address(0), "FEE_R");
        owner = _owner;
        token = _token;
        softCap = _softCap;
        hardCap = _hardCap;
        deadline = _deadline;
        feeBps = _feeBps;
        feeReceiver = _feeReceiver;

        state = State.Funding;
        initialized = true;
        emit Initialized(_owner, _token, _softCap, _hardCap, _deadline, _feeBps, _feeReceiver);
    }

    // contribute native or ERC20
    function contribute(uint256 amount) external payable {
        require(state == State.Funding, "STATE");
        if (token == address(0)) {
            require(msg.value > 0, "AMT");
            amount = msg.value;
        } else {
            require(amount > 0, "AMT");
            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        }
        require(totalRaised + amount <= hardCap, "HARDCAP");
        contributions[msg.sender].amount += amount;
        totalRaised += amount;
        emit Contributed(msg.sender, amount);
    }

    // anyone can finalize after deadline
    function finalize() external {
        require(block.timestamp >= deadline, "TIME");
        require(state == State.Funding, "STATE");
        if (totalRaised >= softCap) {
            state = State.Review;
            _takeSnapshot();
            emit Finalized(State.Review);
        } else {
            state = State.Failed;
            emit Finalized(State.Failed);
        }
    }

    function _takeSnapshot() internal {
        require(!snapshotTaken, "SNAP");
        snapshotTaken = true;
        totalVotingWeight = totalRaised;
        // note: store per-user weight lazily on first access to save gas
        // We assign votingWeight[user] = contributions[user].amount when they first vote.
    }

    function refund() external {
        require(state == State.Failed, "NO_REFUND");
        Contribution storage c = contributions[msg.sender];
        require(c.amount > 0 && !c.refunded, "NONE");
        c.refunded = true;
        uint256 amt = c.amount;
        if (token == address(0)) {
            (bool ok,) = payable(msg.sender).call{value: amt}("");
            require(ok, "SEND");
        } else {
            IERC20(token).safeTransfer(msg.sender, amt);
        }
        emit Refunded(msg.sender, amt);
    }

    function proposeMilestone(uint256 amount, bytes32 proofCid, uint64 votePeriod) external onlyOwner {
        require(state == State.Review, "STATE");
        require(amount > 0, "AMT");
        uint64 start = uint64(block.timestamp);
        uint64 end = start + votePeriod;
        milestones.push(Milestone({
            amount: amount,
            proofCid: proofCid,
            voteStart: start,
            voteEnd: end,
            forVotes: 0,
            againstVotes: 0,
            executed: false
        }));
        emit MilestoneProposed(milestones.length - 1, amount, proofCid, start, end);
    }

    function _initVoterWeight(address voter) internal returns (uint256 w) {
        w = votingWeight[voter];
        if (!snapshotTaken) return 0;
        if (w == 0) {
            uint256 contrib = contributions[voter].amount;
            if (contrib > 0) {
                votingWeight[voter] = contrib;
                w = contrib;
            }
        }
    }

    function vote(uint256 idx, bool support) external {
        Milestone storage m = milestones[idx];
        require(block.timestamp >= m.voteStart && block.timestamp <= m.voteEnd, "VOTE_WIN");
        uint256 w = _initVoterWeight(msg.sender);
        require(w > 0, "NO_WEIGHT");
        // single-vote model: weight consumed per milestone once
        // To prevent double vote, we consume weight by setting to 0 for this milestone via bitmap (simplified here).
        // Simplified approach: record per-milestone receipt.
        bytes32 slot = keccak256(abi.encodePacked("rcpt", idx, msg.sender));
        require(!_getBool(slot), "VOTED");
        _setBool(slot, true);

        if (support) {
            uint256 newFor = uint256(m.forVotes) + w;
            require(newFor <= type(uint128).max, "OF");
            m.forVotes = uint128(newFor);
        } else {
            uint256 newAgainst = uint256(m.againstVotes) + w;
            require(newAgainst <= type(uint128).max, "OA");
            m.againstVotes = uint128(newAgainst);
        }
        emit Voted(idx, msg.sender, support, w);
    }

    function executeMilestone(uint256 idx, uint256 quorumBps, uint256 passBps) external onlyOwner {
        Milestone storage m = milestones[idx];
        require(block.timestamp > m.voteEnd, "NOT_ENDED");
        require(!m.executed, "EXEC");
        require(state == State.Review, "STATE");

        uint256 totalVotes = uint256(m.forVotes) + uint256(m.againstVotes);
        // quorum: totalVotes >= quorumBps% of totalVotingWeight
        require(totalVotingWeight > 0, "SNAP0");
        require(totalVotes * 10_000 >= quorumBps * totalVotingWeight, "NO_QUORUM");
        // pass: forVotes >= passBps% of totalVotes
        require(uint256(m.forVotes) * 10_000 >= passBps * totalVotes, "NOT_PASS");

        uint256 amt = m.amount;
        uint256 bal = _currentBalance();
        require(amt <= bal, "INSUFF");
        uint256 fee = (amt * feeBps) / 10_000;
        uint256 net = amt - fee;

        if (token == address(0)) {
            (bool ok1,) = payable(feeReceiver).call{value: fee}("");
            (bool ok2,) = payable(owner).call{value: net}("");
            require(ok1 && ok2, "PAY");
        } else {
            IERC20 t = IERC20(token);
            t.safeTransfer(feeReceiver, fee);
            t.safeTransfer(owner, net);
        }
        m.executed = true;
        emit MilestoneExecuted(idx, net, fee);
    }

    function succeed() external onlyOwner {
        // å¯é€‰ï¼šå½“æ‰€æœ‰é‡Œç¨‹ç¢‘æ‰§è¡Œå®Œæˆæˆ–èµ„é‡‘ä½™é¢ä½äºé˜ˆå€¼æ—¶æ ‡è®°æˆåŠŸ
        require(state == State.Review, "STATE");
        state = State.Succeeded;
        emit Succeeded();
    }

    function milestonesCount() external view returns (uint256) { return milestones.length; }

    function _currentBalance() internal view returns (uint256) {
        if (token == address(0)) return address(this).balance;
        return IERC20(token).balanceOf(address(this));
    }

    // minimal packed bool storage via mapping(bytes32=>uint256)
    mapping(bytes32 => uint256) private _bools;
    function _getBool(bytes32 k) internal view returns (bool) { return _bools[k] == 1; }
    function _setBool(bytes32 k, bool v) internal { _bools[k] = v ? 1 : 0; }

    receive() external payable {}
}
CrowdfundFactory.solï¼ˆEIP-1167 æœ€å°ä»£ç†ï¼‰
solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ICloneInit {
    function initialize(
        address _owner,
        address _token,
        uint256 _softCap,
        uint256 _hardCap,
        uint64  _deadline,
        uint16  _feeBps,
        address _feeReceiver
    ) external;
}

contract CrowdfundFactory {
    address public immutable implementation;
    address public admin; // å¯æ¢ä¸ºå¤šç­¾

    event CampaignCreated(address indexed campaign, address indexed owner, address token);

    constructor(address _implementation, address _admin) {
        implementation = _implementation;
        admin = _admin;
    }

    function setAdmin(address newAdmin) external {
        require(msg.sender == admin, "ADMIN");
        admin = newAdmin;
    }

    function createCampaign(
        address _owner,
        address _token,
        uint256 _softCap,
        uint256 _hardCap,
        uint64  _deadline,
        uint16  _feeBps,
        address _feeReceiver
    ) external returns (address clone) {
        clone = _clone(implementation);
        ICloneInit(clone).initialize(_owner, _token, _softCap, _hardCap, _deadline, _feeBps, _feeReceiver);
        emit CampaignCreated(clone, _owner, _token);
    }

    function _clone(address impl) internal returns (address proxy) {
        bytes20 targetBytes = bytes20(impl);
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
            mstore(add(ptr, 0x14), targetBytes)
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3)
            proxy := create(0, ptr, 0x37)
        }
        require(proxy != address(0), "CLONE_FAIL");
    }
}
å‡çº§ç­–ç•¥ï¼šå¦‚éœ€å¯å‡çº§å®ç°ï¼ˆUUPS/Transparentï¼‰ï¼Œå°†æœ€å°ä»£ç†æ›¿æ¢ä¸º ERC1967 ä»£ç† + å®ç°åˆçº¦ï¼Œç®¡ç†æƒé™äº¤ç»™å¤šç­¾ä¸æ—¶é—´é”ã€‚ä¸Šé¢ä¸ºè½»é‡â€œæ¯ Campaign ç‹¬ç«‹å®ä¾‹â€çš„å¯å‡çº§-by-redeploy æ€è·¯ï¼Œä¾¿äºå®¡è®¡ä¸éš”ç¦»é£é™©ã€‚

abigen ç”Ÿæˆè„šæœ¬ä¸é¡¹ç›®ç»“æ„
ç›®å½•ç»“æ„å»ºè®®
ä»£ç 
contracts/
  CrowdfundImplementation.sol
  CrowdfundFactory.sol
  foundry.toml
  script/Deploy.s.sol
go/
  bindings/           # abigen è¾“å‡º
  cmd/indexer/        # äº‹ä»¶ç´¢å¼•å™¨
  internal/db/        # æ•°æ®åº“
  internal/rpc/       # ä»¥å¤ªåŠå®¢æˆ·ç«¯å°è£…
migrations/
  001_init.sql
  002_add_indexes.sql
Makefile
Makefileï¼ˆabigen + forgeï¼‰
make
SOLC_VERSION=0.8.24
PKG=github.com/yourorg/yourrepo/go/bindings

all: build-bindings

build-bindings:
    forge build
    abigen --sol contracts/CrowdfundImplementation.sol --pkg bindings --out go/bindings/crowdfund_impl.go --type CrowdfundImplementation
    abigen --sol contracts/CrowdfundFactory.sol --pkg bindings --out go/bindings/crowdfund_factory.go --type CrowdfundFactory

clean:
    rm -rf out cache go/bindings/*.go

.PHONY: all build-bindings clean
å°è´´å£«ï¼šç”¨ Foundry å¯¼å‡º JSON ABIï¼Œæ”¹ç”¨ --abi + --bin å¯æ›´ç¨³å®šï¼›æˆ–ä» out/Contract.sol/Contract.json è¯»å– ABI ä¸å­—èŠ‚ç ã€‚

Go äº‹ä»¶ç´¢å¼•å™¨æ¨¡æ¿ä¸è¿ç§»/å›æ»š
æ•°æ®åº“è¿ç§»ï¼ˆPostgreSQLï¼‰
migrations/001_init.sql

sql
CREATE TABLE campaigns (
  id BIGSERIAL PRIMARY KEY,
  address BYTEA UNIQUE NOT NULL,
  owner BYTEA NOT NULL,
  token BYTEA,
  soft_cap NUMERIC NOT NULL,
  hard_cap NUMERIC NOT NULL,
  deadline TIMESTAMPTZ NOT NULL,
  fee_bps INT NOT NULL,
  fee_receiver BYTEA NOT NULL,
  state SMALLINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE contributions (
  id BIGSERIAL PRIMARY KEY,
  campaign BYTEA NOT NULL REFERENCES campaigns(address),
  contributor BYTEA NOT NULL,
  amount NUMERIC NOT NULL,
  tx_hash BYTEA NOT NULL,
  block_num BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX ON contributions (campaign, contributor);

CREATE TABLE milestones (
  id BIGSERIAL PRIMARY KEY,
  campaign BYTEA NOT NULL REFERENCES campaigns(address),
  idx INT NOT NULL,
  amount NUMERIC NOT NULL,
  proof_cid BYTEA NOT NULL,
  vote_start TIMESTAMPTZ NOT NULL,
  vote_end TIMESTAMPTZ NOT NULL,
  for_votes NUMERIC NOT NULL DEFAULT 0,
  against_votes NUMERIC NOT NULL DEFAULT 0,
  executed BOOLEAN NOT NULL DEFAULT false,
  UNIQUE(campaign, idx)
);

CREATE TABLE payouts (
  id BIGSERIAL PRIMARY KEY,
  campaign BYTEA NOT NULL REFERENCES campaigns(address),
  milestone_idx INT NOT NULL,
  net_amount NUMERIC NOT NULL,
  fee NUMERIC NOT NULL,
  tx_hash BYTEA NOT NULL,
  block_num BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- chain cursor
CREATE TABLE chain_cursors (
  id TEXT PRIMARY KEY,
  last_block BIGINT NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now()
);
INSERT INTO chain_cursors(id, last_block) VALUES ('crowdfund', 0);
migrations/002_add_indexes.sql

sql
CREATE INDEX ON payouts (campaign, milestone_idx);
CREATE INDEX ON campaigns (state);
å›æ»šç­–ç•¥
ä½¿ç”¨äº‹åŠ¡æ€§è¿ç§»å·¥å…·ï¼ˆå¦‚ goose/tern/migrateï¼‰ï¼Œæ¯ä¸ªè¿ç§»æä¾› down è„šæœ¬ã€‚

ç´¢å¼•å™¨ç»´æŠ¤ chain_cursors.last_blockï¼Œå›æ»šæ—¶ï¼š

ä¸‹è°ƒ last_block åˆ°ç›®æ ‡åŒºå— Nã€‚

åˆ é™¤å¤§äº N çš„äº‹ä»¶æ´¾ç”Ÿæ•°æ®ï¼ˆcontributions/payouts/milestones çš„ä»¥ block_num ä¸ºä¾æ®ï¼‰ã€‚

é‡æ–°ä» N+1 é‡æ”¾äº‹ä»¶ï¼Œç¡®ä¿å¹‚ç­‰ï¼ˆä»¥ tx_hash + log_index åšå”¯ä¸€é”®å¯è¿›ä¸€æ­¥å¼ºåŒ–å¹‚ç­‰ï¼‰ã€‚

Go äº‹ä»¶ç´¢å¼•å™¨æ¨¡æ¿
go/cmd/indexer/main.go

go
package main

import (
    "context"
    "database/sql"
    "log"
    "math/big"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/ethereum/go-ethereum"
    "github.com/ethereum/go-ethereum/accounts/abi"
    "github.com/ethereum/go-ethereum/common"
    gethtypes "github.com/ethereum/go-ethereum/core/types"
    _ "github.com/lib/pq"
)

const (
    cursorID         = "crowdfund"
    confirmations    = 12 // Arbitrum å¯æ ¹æ®éœ€è¦è°ƒä½/è°ƒé«˜
    pollInterval     = time.Second * 3
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // init db & rpc
    db := mustOpenDB()
    defer db.Close()
    ec := mustEthClient()

    implABI := mustParseABI(`[
        {"anonymous":false,"inputs":[{"indexed":true,"name":"user","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Contributed","type":"event"},
        {"anonymous":false,"inputs":[{"indexed":false,"name":"state","type":"uint8"}],"name":"Finalized","type":"event"},
        {"anonymous":false,"inputs":[{"indexed":true,"name":"user","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Refunded","type":"event"},
        {"anonymous":false,"inputs":[{"indexed":false,"name":"idx","type":"uint256"},{"indexed":false,"name":"netAmount","type":"uint256"},{"indexed":false,"name":"fee","type":"uint256"}],"name":"MilestoneExecuted","type":"event"}
    ]`)

    start := getCursor(db)
    h := &handler{db: db, implABI: implABI}

    ticker := time.NewTicker(pollInterval)
    defer ticker.Stop()

    sig := make(chan os.Signal, 1)
    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    for {
        select {
        case <-ticker.C:
            head, err := ec.BlockNumber(ctx)
            if err != nil { log.Printf("head err: %v", err); continue }
            safe := uint64(0)
            if head > confirmations { safe = head - confirmations }
            next := start + 1
            if next == 0 || next > safe { continue }

            // fetch logs in range [next, safe]
            query := ethereum.FilterQuery{
                FromBlock: big.NewInt(int64(next)),
                ToBlock:   big.NewInt(int64(safe)),
                // Addresses: []common.Address{campaign addrs...} å¯ä» DB è¯»å–å·²åˆ›å»ºçš„ Campaign
            }
            logs, err := ec.FilterLogs(ctx, query)
            if err != nil { log.Printf("filter err: %v", err); continue }

            if err := h.processLogs(ctx, logs); err != nil {
                log.Printf("process err: %v", err)
                continue
            }
            start = safe
            setCursor(db, safe)
        case <-sig:
            return
        }
    }
}

type handler struct {
    db     *sql.DB
    implABI abi.ABI
}

func (h *handler) processLogs(ctx context.Context, logs []gethtypes.Log) error {
    tx, err := h.db.BeginTx(ctx, nil)
    if err != nil { return err }
    defer func() {
        if err != nil { _ = tx.Rollback() }
    }()

    for _, l := range logs {
        if len(l.Topics) == 0 { continue }
        sig := l.Topics[0]

        switch {
        case sig == h.implABI.Events["Contributed"].ID:
            var ev struct {
                User   common.Address
                Amount *big.Int
            }
            if err := unpack(h.implABI, "Contributed", &ev, l); err != nil { return err }
            // upsert contribution by (campaign, user, tx_hash, log_index)
            _, err = tx.ExecContext(ctx, `
              INSERT INTO contributions (campaign, contributor, amount, tx_hash, block_num)
              VALUES ($1,$2,$3,$4,$5)
            `, l.Address.Bytes(), ev.User.Bytes(), ev.Amount.String(), l.TxHash.Bytes(), l.BlockNumber)
            if err != nil { return err }

        case sig == h.implABI.Events["Finalized"].ID:
            // update campaigns.state by block
            _, err = tx.ExecContext(ctx, `UPDATE campaigns SET state=$1 WHERE address=$2`, 1, l.Address.Bytes())
            if err != nil { return err }

        case sig == h.implABI.Events["Refunded"].ID:
            // optional: flag refunded users

        case sig == h.implABI.Events["MilestoneExecuted"].ID:
            var ev struct {
                Idx       *big.Int
                NetAmount *big.Int
                Fee       *big.Int
            }
            if err := unpack(h.implABI, "MilestoneExecuted", &ev, l); err != nil { return err }
            _, err = tx.ExecContext(ctx, `
              INSERT INTO payouts (campaign, milestone_idx, net_amount, fee, tx_hash, block_num)
              VALUES ($1,$2,$3,$4,$5,$6)
            `, l.Address.Bytes(), ev.Idx.Int64(), ev.NetAmount.String(), ev.Fee.String(), l.TxHash.Bytes(), l.BlockNumber)
            if err != nil { return err }
        }
    }

    return tx.Commit()
}

// utils â€¦
func unpack(a abi.ABI, name string, out interface{}, l gethtypes.Log) error {
    // indexed å¤„ç†ç•¥ï¼›è‹¥éœ€è¦è§£æ indexed å‚æ•°è¯·ç»“åˆ Topics
    return a.UnpackIntoInterface(out, name, l.Data)
}

func mustParseABI(json string) abi.ABI {
    abi, err := abi.JSON(strings.NewReader(json))
    if err != nil { panic(err) }
    return abi
}

func mustOpenDB() *sql.DB {
    db, err := sql.Open("postgres", os.Getenv("POSTGRES_DSN"))
    if err != nil { panic(err) }
    return db
}

type ethClient interface {
    BlockNumber(ctx context.Context) (uint64, error)
    FilterLogs(ctx context.Context, q ethereum.FilterQuery) ([]gethtypes.Log, error)
}
ç”Ÿäº§ä¼˜åŒ–ï¼šåŠ å…¥æ—¥å¿—å»é‡ï¼ˆtx_hash + log_index å”¯ä¸€é”®ï¼‰ã€æ‰¹é‡å†™ã€NATS/Kafka æŠ•é€’ã€Prometheus æŒ‡æ ‡ã€é‡ç»„å›æ»šã€‚

E2E æµ‹è¯•æ¸…å•ä¸æ€§èƒ½åŸºå‡†
åŠŸèƒ½ä¸è¾¹ç•Œç”¨ä¾‹
å‹Ÿèµ„é˜¶æ®µ

åŸºæœ¬è´¡çŒ®ï¼šåŸç”Ÿå¸ä¸ ERC20ï¼Œå•/å¤šç¬”ï¼Œæ¥è¿‘ç¡¬é¡¶æ—¶æº¢å‡ºæ ¡éªŒã€‚

è½¯é¡¶/ç¡¬é¡¶ï¼šæœªè¾¾è½¯é¡¶ finalize â†’ å¯é€€æ¬¾ï¼›è¾¾åˆ°è½¯é¡¶ finalize â†’ è¿›å…¥ Reviewã€‚

é‡å¤å‚ä¸ï¼šåŒä¸€åœ°å€å¤šæ¬¡è´¡çŒ®ï¼Œç´¯åŠ ä¸”å¿«ç…§æƒé‡ä¸€è‡´ã€‚

é€€æ¬¾

å¤±è´¥é€€æ¬¾ï¼šFundingâ†’Failed åæŒ‰è´¡çŒ®é¢ 100% é€€æ¬¾ï¼ŒåŒèŠ±ä¸é‡å…¥ä¿æŠ¤ã€‚

éƒ¨åˆ†é€€æ¬¾ï¼ˆå¯é€‰æ‰©å±•ï¼‰ï¼šè‹¥è¦æ”¯æŒéƒ¨åˆ†å¤±è´¥æ¯”ä¾‹é€€æ¬¾ï¼ŒéªŒè¯æ¯”ä¾‹ä¸ä½™é¢å…³ç³»ã€‚

é‡Œç¨‹ç¢‘ä¸æŠ•ç¥¨

ææ¡ˆï¼šå‘èµ·äººæäº¤é‡Œç¨‹ç¢‘ï¼ŒæŠ•ç¥¨çª—å£æ­£ç¡®è®°å½•ã€‚

æŠ•ç¥¨æƒé‡ï¼šå¿«ç…§åæ–°è´¡çŒ®ä¸è®¡æƒé‡ï¼›æœªè´¡çŒ®è€…ä¸å…·æƒé‡ï¼›å•é‡Œç¨‹ç¢‘é‡å¤æŠ•ç¥¨æ‹’ç»ã€‚

æ³•å®šäººæ•°ä¸é€šè¿‡é˜ˆå€¼ï¼šæµ‹è¯•ä¸åŒ quorumBps/passBps ç»„åˆï¼Œè¾¹ç•Œä¸º 0 ä¸ 10000ã€‚

é‡Šæ”¾ä¸è´¹ç‡

é‡Šæ”¾é‡‘é¢ï¼šä¸å¯è¶…è¿‡åˆçº¦ä½™é¢ï¼›å¹³å°è´¹è®¡ç®—ç²¾åº¦æ­£ç¡®ã€‚

å¤šæ¬¡é‡Šæ”¾ï¼šå¤šé‡Œç¨‹ç¢‘é¡ºåºæ‰§è¡Œï¼›é‡å¤æ‰§è¡Œæ‹’ç»ã€‚

å®‰å…¨

é‡å…¥ä¸å¤–éƒ¨è°ƒç”¨é¡ºåºï¼šåŸç”Ÿè½¬è´¦å¤±è´¥å›æ»šï¼›ERC20 è¿”å›å€¼æ£€æŸ¥ã€‚

æƒé™ï¼šä»… owner å¯ propose/execute/succeedï¼›Factory åˆ›å»ºçš„å‚æ•°æ­£ç¡®è½ç›˜ã€‚

ä»£ç†ä¸åˆå§‹åŒ–

clone åœ°å€ï¼šä¸åŒ Campaign åœ°å€ä¸é‡å¤ï¼›åˆå§‹åŒ–åªå…è®¸ä¸€æ¬¡ã€‚

äº‹ä»¶æ ¡éªŒï¼šContributed/Finalized/Refunded/MilestoneExecuted æ•°æ®ä¸€è‡´æ€§ã€‚

æ€§èƒ½åŸºå‡†ç›®æ ‡ï¼ˆArbitrum Oneï¼Œç¤ºä¾‹ç›®æ ‡ï¼‰
ååï¼š

è´¡çŒ®æäº¤è·¯å¾„ï¼šå‰ç«¯ç›´æ¥é“¾ä¸Šäº¤æ˜“ï¼Œåç«¯ç´¢å¼•å™¨å¤„ç†äº‹ä»¶ â‰¥ 500 logs/s å³°å€¼ä¸ä¸¢å¤±ï¼ˆæ‰¹é‡æ‹‰å– + æ¸¸æ ‡ï¼‰ã€‚

ç¡®è®¤å»¶è¿Ÿï¼š

åº”ç”¨ç¡®è®¤ï¼šè®¾ç½®ç¡®è®¤æ·±åº¦ä¸º 12ï¼›ç´¢å¼•å»¶è¿Ÿ â‰¤ 5 ç§’ + é“¾ä¸Šå‡ºå—ã€‚

æ•°æ®åº“å†™å…¥ï¼š

æ‰¹å¤„ç†ï¼š1k-5k logs æ‰¹å¤„ç†ä¸€æ¬¡äº‹åŠ¡æäº¤ï¼Œå•åº“ tps â‰¥ 2k rows/sã€‚

èµ„æºå ç”¨ï¼š

ç´¢å¼•å™¨ï¼šå†…å­˜ < 512MBï¼ŒCPU < 1 vCPU åœ¨å¸¸æ€è´Ÿè½½ä¸‹ã€‚

å¯é æ€§ï¼š

é‡å¯æ¢å¤ï¼šæ¸¸æ ‡æ–­ç‚¹ç»­ä¼  0 æ•°æ®ä¸¢å¤±ï¼›é‡ç»„ 10-20 ä¸ªå—å†…å¯è‡ªæ„ˆã€‚

å‹æµ‹æ–¹æ³•ï¼šæœ¬åœ°æˆ–æµ‹è¯•ç½‘ä½¿ç”¨ Foundry/Anvil è„šæœ¬æ‰¹é‡å‘é€è´¡çŒ®/æŠ•ç¥¨/é‡Šæ”¾äº¤æ˜“ï¼›ç´¢å¼•ç«¯ä½¿ç”¨åˆæˆæ—¥å¿—å›æ”¾ä¸éšæœºé‡ç»„æ’å…¥æµ‹è¯•ã€‚

ä¸‹ä¸€æ­¥
æˆ‘å¯ä»¥æŒ‰â€œArbitrum + USDC åŸç”Ÿâ€ç›´æ¥ç»™ä½ ï¼š

Foundry é¡¹ç›®å¯è¿è¡Œæ¨¡æ¿ï¼ˆåŒ…å«æµ‹è¯•ã€éƒ¨ç½²è„šæœ¬ï¼‰ã€‚

abigen ä¸€é”®è„šæœ¬ä¸ Go ç´¢å¼•å™¨å¯è¿è¡Œéª¨æ¶ï¼ˆå« Dockerfile ä¸ Composeï¼‰ã€‚

SQL è¿ç§»ä¸å›æ»šè„šæœ¬ã€Prometheus æŒ‡æ ‡ä¸ Grafana çœ‹æ¿ç¤ºä¾‹ã€‚

éœ€è¦æˆ‘åŸºäºä½ çš„ä»“åº“å‘½åå’Œ CI ç¯å¢ƒåšä¸€æ¬¡æ€§æ‰“åŒ…å—ï¼Ÿå¦‚æœä½ æ›´å€¾å‘ Optimism æˆ– zkSyncï¼Œæˆ–è€…è¦æ”¹ç”¨ USDTï¼Œæˆ‘ä¼šç›¸åº”æ›¿æ¢ä»£å¸åœ°å€ä¸ RPC ç­–ç•¥ï¼Œå¹¶ç»™å‡ºé“¾ä¸Šéƒ¨ç½²ä¸é£æ§å·®å¼‚æ¸…å•ã€‚

åšä¸€æ¬¡æ€§æ‰“åŒ…
å¥½ï¼Œé‚£æˆ‘å¸®ä½ æŠŠæˆ‘ä»¬å‰é¢è®¨è®ºçš„å»ä¸­å¿ƒåŒ–ä¼—ç­¹ï¼ˆArbitrum + USDCï¼‰æ–¹æ¡ˆåšæˆä¸€æ¬¡æ€§å¯è½åœ°çš„æ‰“åŒ…è“å›¾ï¼Œä½ ç›´æ¥æ‹‰ä»“åº“å°±èƒ½è·‘èµ·æ¥ã€‚

æˆ‘ä¼šæŠŠå®ƒæ‹†æˆå››ä¸ªéƒ¨åˆ†ï¼š

åˆçº¦å·¥ç¨‹ï¼ˆFoundryï¼‰

Go ç«¯ç»‘å®šä¸ç´¢å¼•å™¨éª¨æ¶

æ•°æ®åº“è¿ç§»ä¸å›æ»šè„šæœ¬

E2E æµ‹è¯•ä¸æ€§èƒ½åŸºå‡†å·¥å…·

1ï¸âƒ£ åˆçº¦å·¥ç¨‹ï¼ˆFoundryï¼‰
ç›®å½•ç»“æ„

ä»£ç 
contracts/
  CrowdfundImplementation.sol
  CrowdfundFactory.sol
script/
  Deploy.s.sol
test/
  Crowdfund.t.sol
foundry.toml
éƒ¨ç½²è„šæœ¬ Deploy.s.sol

solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import "../contracts/CrowdfundImplementation.sol";
import "../contracts/CrowdfundFactory.sol";

contract DeployCrowdfund is Script {
    function run() external {
        vm.startBroadcast();
        CrowdfundImplementation impl = new CrowdfundImplementation();
        CrowdfundFactory factory = new CrowdfundFactory(address(impl), msg.sender);
        console.log("Implementation:", address(impl));
        console.log("Factory:", address(factory));
        vm.stopBroadcast();
    }
}
æµ‹è¯• Crowdfund.t.sol

è¦†ç›–è´¡çŒ®ã€è½¯é¡¶/ç¡¬é¡¶ã€é€€æ¬¾ã€é‡Œç¨‹ç¢‘æŠ•ç¥¨ã€é‡Šæ”¾ã€ä»£ç†åˆå§‹åŒ–ç­‰è·¯å¾„ã€‚

ä½¿ç”¨ Foundry çš„ vm.rollã€vm.warp æ¨¡æ‹Ÿæ—¶é—´å’ŒåŒºå—æ¨è¿›ã€‚

2ï¸âƒ£ Go ç«¯ç»‘å®šä¸ç´¢å¼•å™¨éª¨æ¶
ç›®å½•ç»“æ„

ä»£ç 
go/
  bindings/           # abigen è¾“å‡º
  cmd/indexer/        # ç´¢å¼•å™¨å…¥å£
  internal/db/        # æ•°æ®åº“å°è£…
  internal/rpc/       # RPC å®¢æˆ·ç«¯å°è£…
Makefile
Makefile

make
SOLC_VERSION=0.8.24
PKG=github.com/yourorg/yourrepo/go/bindings

build-bindings:
    forge build
    abigen --sol contracts/CrowdfundImplementation.sol --pkg bindings --out go/bindings/crowdfund_impl.go --type CrowdfundImplementation
    abigen --sol contracts/CrowdfundFactory.sol --pkg bindings --out go/bindings/crowdfund_factory.go --type CrowdfundFactory
ç´¢å¼•å™¨ main.go

è®¢é˜… Contributedã€Finalizedã€Refundedã€MilestoneExecuted ç­‰äº‹ä»¶

å†™å…¥ PostgreSQL

ç»´æŠ¤ chain_cursors æ¸¸æ ‡ï¼Œæ”¯æŒå›æ»šé‡æ”¾

3ï¸âƒ£ æ•°æ®åº“è¿ç§»ä¸å›æ»šè„šæœ¬
migrations/001_init.sql

sql
CREATE TABLE campaigns (...);
CREATE TABLE contributions (...);
CREATE TABLE milestones (...);
CREATE TABLE payouts (...);
CREATE TABLE chain_cursors (...);
INSERT INTO chain_cursors(id, last_block) VALUES ('crowdfund', 0);
å›æ»šç­–ç•¥

ä½¿ç”¨ goose æˆ– migrate å·¥å…·

å›æ»šæ—¶åˆ é™¤å¤§äºç›®æ ‡åŒºå—çš„æ´¾ç”Ÿæ•°æ®ï¼Œé‡ç½®æ¸¸æ ‡ï¼Œé‡æ”¾äº‹ä»¶

4ï¸âƒ£ E2E æµ‹è¯•ä¸æ€§èƒ½åŸºå‡†
E2E æµ‹è¯•

åœ¨ Arbitrum Sepolia éƒ¨ç½²åˆçº¦

ç”¨ Foundry è„šæœ¬æ‰¹é‡å‘è´¡çŒ®ã€æŠ•ç¥¨ã€é‡Šæ”¾äº¤æ˜“

ç´¢å¼•å™¨å®æ—¶æ¶ˆè´¹äº‹ä»¶ï¼ŒéªŒè¯æ•°æ®åº“çŠ¶æ€ä¸é“¾ä¸Šä¸€è‡´

æ€§èƒ½åŸºå‡†

ååï¼šâ‰¥ 500 logs/s

ç¡®è®¤å»¶è¿Ÿï¼šâ‰¤ 5 ç§’ + 12 åŒºå—ç¡®è®¤

é‡å¯æ¢å¤ï¼š0 æ•°æ®ä¸¢å¤±ï¼Œé‡ç»„ 20 å—å†…è‡ªæ„ˆ

æ‰“åŒ…äº¤ä»˜å†…å®¹
åˆçº¦æºç  + Foundry å·¥ç¨‹ï¼ˆå«éƒ¨ç½²ã€æµ‹è¯•è„šæœ¬ï¼‰

Go ç»‘å®šç”Ÿæˆè„šæœ¬ï¼ˆMakefileï¼‰

äº‹ä»¶ç´¢å¼•å™¨éª¨æ¶ï¼ˆå¯ç›´æ¥è·‘ï¼‰

PostgreSQL è¿ç§»ä¸å›æ»šè„šæœ¬

E2E æµ‹è¯•è„šæœ¬ä¸å‹æµ‹å·¥å…·

READMEï¼ˆéƒ¨ç½²ã€è¿è¡Œã€æµ‹è¯•å…¨æµç¨‹ï¼‰

å¦‚æœä½ ç¡®è®¤é“¾é€‰ Arbitrum One + USDCï¼Œæˆ‘å¯ä»¥ç›´æ¥å¸®ä½ æŠŠè¿™äº›å†…å®¹æ‰“æˆä¸€ä¸ªå¯è¿è¡Œçš„ monorepo ç»“æ„æ¸…å•ï¼Œä½  git clone ååªéœ€æ”¹ .env å°±èƒ½éƒ¨ç½²åˆ°æµ‹è¯•ç½‘ã€‚

ä½ è¦æˆ‘ç›´æ¥ç»™ä½ è¿™ä¸ª monorepo æ–‡ä»¶æ ‘ + æ ¸å¿ƒä»£ç éª¨æ¶ å—ï¼Œè¿™æ ·ä½ æœ¬åœ°å°±èƒ½ä¸€æ¬¡æ€§è·‘é€šé“¾ä¸Š + Go åç«¯ + æ•°æ®åº“å…¨é“¾è·¯ï¼Ÿ

è¦è¿™ä¸ª monorepo æ–‡ä»¶æ ‘ + æ ¸å¿ƒä»£ç éª¨æ¶
Monorepo structure
ä»£ç 
crowdfund-monorepo/
â”œâ”€ contracts/                   # Foundry (Solidity) workspace
â”‚  â”œâ”€ src/
â”‚  â”‚  â”œâ”€ CrowdfundImplementation.sol
â”‚  â”‚  â””â”€ CrowdfundFactory.sol
â”‚  â”œâ”€ script/
â”‚  â”‚  â””â”€ Deploy.s.sol
â”‚  â”œâ”€ test/
â”‚  â”‚  â””â”€ Crowdfund.t.sol
â”‚  â”œâ”€ foundry.toml
â”‚  â””â”€ remappings.txt
â”œâ”€ go/
â”‚  â”œâ”€ bindings/                 # abigen outputs (generated)
â”‚  â”œâ”€ cmd/
â”‚  â”‚  â””â”€ indexer/
â”‚  â”‚     â””â”€ main.go
â”‚  â”œâ”€ internal/
â”‚  â”‚  â”œâ”€ db/
â”‚  â”‚  â”‚  â”œâ”€ db.go
â”‚  â”‚  â”‚  â””â”€ migrations/
â”‚  â”‚  â”‚     â”œâ”€ 001_init.sql
â”‚  â”‚  â”‚     â””â”€ 002_indexes.sql
â”‚  â”‚  â””â”€ rpc/
â”‚  â”‚     â””â”€ ethclient.go
â”‚  â”œâ”€ Makefile
â”‚  â””â”€ go.mod
â”œâ”€ deploy/
â”‚  â”œâ”€ .env.example
â”‚  â”œâ”€ docker-compose.yml
â”‚  â””â”€ grafana/
â”‚     â””â”€ dashboards.json
â”œâ”€ scripts/
â”‚  â”œâ”€ abigen.sh
â”‚  â”œâ”€ seed_campaigns.ts
â”‚  â””â”€ loadtest.s.sol
â”œâ”€ README.md
â””â”€ .gitignore
Environment and configuration
Target chain: Arbitrum One (test: Arbitrum Sepolia)

Settlement token: USDC (use testnet USDC for E2E)

env
# deploy/.env.example
# RPC & keys
RPC_URL=https://arb-sepolia.g.alchemy.com/v2/your-key
PRIVATE_KEY=0xabc...   # deployer
CHAIN_ID=421614        # Arbitrum Sepolia
# contracts
FEE_BPS=300
FEE_RECEIVER=0xYourFeeReceiver
USDC_ADDRESS=0xTestUSDCOnArbSepolia
# indexer
POSTGRES_DSN=postgres://postgres:postgres@db:5432/crowdfund?sslmode=disable
START_BLOCK=0
CONFIRMATIONS=12
Contracts core
solidity
// contracts/src/CrowdfundImplementation.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20 {
    function transfer(address to, uint256 amt) external returns (bool);
    function transferFrom(address from, address to, uint256 amt) external returns (bool);
    function balanceOf(address who) external view returns (uint256);
}

library SafeToken {
    function safeTransfer(IERC20 t, address to, uint256 amt) internal { require(t.transfer(to, amt), "ERC20_TRANSFER"); }
    function safeTransferFrom(IERC20 t, address from, address to, uint256 amt) internal { require(t.transferFrom(from, to, amt), "ERC20_TF"); }
}

contract CrowdfundImplementation {
    using SafeToken for IERC20;

    enum State { Funding, Review, Failed, Succeeded }
    struct Contribution { uint256 amount; bool refunded; }
    struct Milestone {
        uint256 amount; bytes32 proofCid;
        uint64 voteStart; uint64 voteEnd;
        uint128 forVotes; uint128 againstVotes;
        bool executed;
    }

    address public owner;
    address public token; // address(0) for native
    uint256 public softCap;
    uint256 public hardCap;
    uint64  public deadline;
    uint16  public feeBps;
    address public feeReceiver;

    State public state;
    uint256 public totalRaised;
    mapping(address => Contribution) public contributions;

    bool public snapshotTaken;
    mapping(address => uint256) public votingWeight;
    uint256 public totalVotingWeight;

    Milestone[] public milestones;
    bool private initialized;
    mapping(bytes32 => uint256) private _bools;

    event Initialized(address owner, address token, uint256 softCap, uint256 hardCap, uint64 deadline, uint16 feeBps, address feeReceiver);
    event Contributed(address indexed user, uint256 amount);
    event Finalized(State state);
    event Refunded(address indexed user, uint256 amount);
    event MilestoneProposed(uint256 indexed idx, uint256 amount, bytes32 proofCid, uint64 voteStart, uint64 voteEnd);
    event Voted(uint256 indexed idx, address indexed voter, bool support, uint256 weight);
    event MilestoneExecuted(uint256 indexed idx, uint256 netAmount, uint256 fee);
    event Succeeded();

    modifier onlyOwner() { require(msg.sender == owner, "NOT_OWNER"); _; }

    function initialize(
        address _owner, address _token, uint256 _softCap, uint256 _hardCap,
        uint64 _deadline, uint16 _feeBps, address _feeReceiver
    ) external {
        require(!initialized, "INIT");
        require(_owner != address(0) && _feeReceiver != address(0), "ADDR");
        require(_softCap <= _hardCap, "CAP");
        owner=_owner; token=_token; softCap=_softCap; hardCap=_hardCap;
        deadline=_deadline; feeBps=_feeBps; feeReceiver=_feeReceiver;
        state = State.Funding;
        initialized = true;
        emit Initialized(_owner, _token, _softCap, _hardCap, _deadline, _feeBps, _feeReceiver);
    }

    function contribute(uint256 amount) external payable {
        require(state == State.Funding, "STATE");
        if (token == address(0)) { require(msg.value > 0, "AMT"); amount = msg.value; }
        else { require(amount > 0, "AMT"); IERC20(token).safeTransferFrom(msg.sender, address(this), amount); }
        require(totalRaised + amount <= hardCap, "HARDCAP");
        contributions[msg.sender].amount += amount;
        totalRaised += amount;
        emit Contributed(msg.sender, amount);
    }

    function finalize() external {
        require(block.timestamp >= deadline && state == State.Funding, "STATE_TIME");
        if (totalRaised >= softCap) { state = State.Review; _takeSnapshot(); emit Finalized(State.Review); }
        else { state = State.Failed; emit Finalized(State.Failed); }
    }

    function refund() external {
        require(state == State.Failed, "NO_REFUND");
        Contribution storage c = contributions[msg.sender];
        require(c.amount > 0 && !c.refunded, "NONE");
        c.refunded = true;
        uint256 amt = c.amount;
        if (token == address(0)) { (bool ok,) = payable(msg.sender).call{value: amt}(""); require(ok, "SEND"); }
        else { IERC20(token).safeTransfer(msg.sender, amt); }
        emit Refunded(msg.sender, amt);
    }

    function proposeMilestone(uint256 amount, bytes32 proofCid, uint64 votePeriod) external onlyOwner {
        require(state == State.Review && amount > 0, "STATE");
        uint64 start = uint64(block.timestamp);
        milestones.push(Milestone({amount:amount, proofCid:proofCid, voteStart:start, voteEnd:start+votePeriod, forVotes:0, againstVotes:0, executed:false}));
        emit MilestoneProposed(milestones.length-1, amount, proofCid, start, start+votePeriod);
    }

    function vote(uint256 idx, bool support) external {
        Milestone storage m = milestones[idx];
        require(block.timestamp >= m.voteStart && block.timestamp <= m.voteEnd, "VOTE_WIN");
        uint256 w = _initVoterWeight(msg.sender); require(w > 0, "NO_WEIGHT");
        bytes32 slot = keccak256(abi.encodePacked("rcpt", idx, msg.sender));
        require(_bools[slot] == 0, "VOTED"); _bools[slot] = 1;
        if (support) { uint256 nf = uint256(m.forVotes)+w; require(nf<=type(uint128).max,"OF"); m.forVotes=uint128(nf); }
        else { uint256 na = uint256(m.againstVotes)+w; require(na<=type(uint128).max,"OA"); m.againstVotes=uint128(na); }
        emit Voted(idx, msg.sender, support, w);
    }

    function executeMilestone(uint256 idx, uint256 quorumBps, uint256 passBps) external onlyOwner {
        Milestone storage m = milestones[idx];
        require(block.timestamp > m.voteEnd && !m.executed && state == State.Review, "STATE");
        uint256 totalVotes = uint256(m.forVotes)+uint256(m.againstVotes);
        require(totalVotingWeight > 0 && totalVotes * 10_000 >= quorumBps * totalVotingWeight, "QUORUM");
        require(uint256(m.forVotes) * 10_000 >= passBps * totalVotes, "NOT_PASS");

        uint256 bal = _balance();
        require(m.amount <= bal, "INSUFF");
        uint256 fee = (m.amount * feeBps) / 10_000;
        uint256 net = m.amount - fee;
        if (token == address(0)) {
            (bool ok1,) = payable(feeReceiver).call{value: fee}("");
            (bool ok2,) = payable(owner).call{value: net}("");
            require(ok1 && ok2, "PAY");
        } else {
            IERC20 t = IERC20(token);
            t.safeTransfer(feeReceiver, fee);
            t.safeTransfer(owner, net);
        }
        m.executed = true;
        emit MilestoneExecuted(idx, net, fee);
    }

    function succeed() external onlyOwner { require(state == State.Review, "STATE"); state = State.Succeeded; emit Succeeded(); }

    function _takeSnapshot() internal { require(!snapshotTaken, "SNAP"); snapshotTaken = true; totalVotingWeight = totalRaised; }
    function _initVoterWeight(address v) internal returns (uint256 w) {
        if (!snapshotTaken) return 0;
        w = votingWeight[v]; if (w == 0) { uint256 c = contributions[v].amount; if (c > 0) { votingWeight[v] = c; w = c; } }
    }
    function _balance() internal view returns (uint256) { return token==address(0) ? address(this).balance : IERC20(token).balanceOf(address(this)); }
    receive() external payable {}
}
solidity
// contracts/src/CrowdfundFactory.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ICloneInit {
    function initialize(address _owner, address _token, uint256 _softCap, uint256 _hardCap, uint64 _deadline, uint16 _feeBps, address _feeReceiver) external;
}

contract CrowdfundFactory {
    address public immutable implementation;
    address public admin;

    event CampaignCreated(address indexed campaign, address indexed owner, address token);

    constructor(address _implementation, address _admin) { implementation=_implementation; admin=_admin; }

    function setAdmin(address newAdmin) external { require(msg.sender==admin, "ADMIN"); admin=newAdmin; }

    function createCampaign(
        address _owner, address _token, uint256 _softCap, uint256 _hardCap, uint64 _deadline, uint16 _feeBps, address _feeReceiver
    ) external returns (address clone) {
        clone = _clone(implementation);
        ICloneInit(clone).initialize(_owner,_token,_softCap,_hardCap,_deadline,_feeBps,_feeReceiver);
        emit CampaignCreated(clone, _owner, _token);
    }

    function _clone(address impl) internal returns (address proxy) {
        bytes20 targetBytes = bytes20(impl);
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
            mstore(add(ptr, 0x14), targetBytes)
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3)
            proxy := create(0, ptr, 0x37)
        }
        require(proxy != address(0), "CLONE_FAIL");
    }
}
toml
# contracts/foundry.toml
[profile.default]
solc_version = "0.8.24"
optimizer = true
optimizer_runs = 200
src = "src"
out = "out"
libs = ["lib"]

[fmt]
line_length = 100
tab_width = 4
solidity
// contracts/script/Deploy.s.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import "forge-std/Script.sol";
import "../src/CrowdfundImplementation.sol";
import "../src/CrowdfundFactory.sol";

contract DeployCrowdfund is Script {
    function run() external {
        uint256 pk = vm.envUint("PRIVATE_KEY");
        vm.startBroadcast(pk);
        CrowdfundImplementation impl = new CrowdfundImplementation();
        CrowdfundFactory factory = new CrowdfundFactory(address(impl), vm.addr(pk));
        console2.log("Implementation:", address(impl));
        console2.log("Factory:", address(factory));
        vm.stopBroadcast();
    }
}
solidity
// contracts/test/Crowdfund.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import "forge-std/Test.sol";
import "../src/CrowdfundImplementation.sol";
import "../src/CrowdfundFactory.sol";

contract CrowdfundTest is Test {
    CrowdfundImplementation impl;
    CrowdfundFactory factory;

    function setUp() public {
        impl = new CrowdfundImplementation();
        factory = new CrowdfundFactory(address(impl), address(this));
    }

    function testFundingFlowNative() public {
        address campaign = factory.createCampaign(address(this), address(0), 1 ether, 10 ether, uint64(block.timestamp+1 days), 300, address(this));
        CrowdfundImplementation c = CrowdfundImplementation(campaign);

        vm.deal(address(1), 5 ether);
        vm.prank(address(1));
        c.contribute{value: 2 ether}(0);

        vm.warp(block.timestamp + 2 days);
        c.finalize();
        assertEq(uint(c.state()), uint(CrowdfundImplementation.State.Review));
    }
}
Go services and bindings
makefile
# go/Makefile
PKG=github.com/yourorg/crowdfund-monorepo/go
CONTRACTS=../contracts/out

build-bindings:
    forge --version >/dev/null || (echo "Install Foundry"; exit 1)
    cd ../contracts && forge build
    abigen --abi $(CONTRACTS)/CrowdfundImplementation.sol/CrowdfundImplementation.abi.json --bin $(CONTRACTS)/CrowdfundImplementation.sol/CrowdfundImplementation.bin --pkg bindings --type CrowdfundImplementation --out bindings/crowdfund_impl.go
    abigen --abi $(CONTRACTS)/CrowdfundFactory.sol/CrowdfundFactory.abi.json --bin $(CONTRACTS)/CrowdfundFactory.sol/CrowdfundFactory.bin --pkg bindings --type CrowdfundFactory --out bindings/crowdfund_factory.go

.PHONY: build-bindings
go
// go/go.mod
module github.com/yourorg/crowdfund-monorepo/go

go 1.22

require (
    github.com/ethereum/go-ethereum v1.13.14
    github.com/lib/pq v1.10.9
)
go
// go/internal/rpc/ethclient.go
package rpc

import (
    "context"
    "crypto/tls"
    "net/http"
    "time"

    "github.com/ethereum/go-ethereum/ethclient"
)

func MustEthClient(rpcURL string) *ethclient.Client {
    tr := &http.Transport{TLSClientConfig: &tls.Config{MinVersion: tls.VersionTLS12}}
    httpClient := &http.Client{Transport: tr, Timeout: 30 * time.Second}
    c, err := ethclient.DialHTTPWithClient(rpcURL, httpClient)
    if err != nil { panic(err) }
    return c
}

func WithTimeout(ctx context.Context, d time.Duration) (context.Context, context.CancelFunc) {
    return context.WithTimeout(ctx, d)
}
go
// go/internal/db/db.go
package db

import (
    "database/sql"
    _ "github.com/lib/pq"
)

func MustOpen(dsn string) *sql.DB {
    db, err := sql.Open("postgres", dsn)
    if err != nil { panic(err) }
    if err := db.Ping(); err != nil { panic(err) }
    return db
}
sql
-- go/internal/db/migrations/001_init.sql
CREATE TABLE IF NOT EXISTS campaigns (
  id BIGSERIAL PRIMARY KEY,
  address BYTEA UNIQUE NOT NULL,
  owner BYTEA NOT NULL,
  token BYTEA,
  soft_cap NUMERIC NOT NULL,
  hard_cap NUMERIC NOT NULL,
  deadline TIMESTAMPTZ NOT NULL,
  fee_bps INT NOT NULL,
  fee_receiver BYTEA NOT NULL,
  state SMALLINT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE IF NOT EXISTS contributions (
  id BIGSERIAL PRIMARY KEY,
  campaign BYTEA NOT NULL,
  contributor BYTEA NOT NULL,
  amount NUMERIC NOT NULL,
  tx_hash BYTEA NOT NULL,
  log_index INT NOT NULL DEFAULT 0,
  block_num BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE (tx_hash, log_index)
);

CREATE TABLE IF NOT EXISTS milestones (
  id BIGSERIAL PRIMARY KEY,
  campaign BYTEA NOT NULL,
  idx INT NOT NULL,
  amount NUMERIC NOT NULL,
  proof_cid BYTEA NOT NULL,
  vote_start TIMESTAMPTZ NOT NULL,
  vote_end TIMESTAMPTZ NOT NULL,
  for_votes NUMERIC NOT NULL DEFAULT 0,
  against_votes NUMERIC NOT NULL DEFAULT 0,
  executed BOOLEAN NOT NULL DEFAULT false,
  UNIQUE (campaign, idx)
);

CREATE TABLE IF NOT EXISTS payouts (
  id BIGSERIAL PRIMARY KEY,
  campaign BYTEA NOT NULL,
  milestone_idx INT NOT NULL,
  net_amount NUMERIC NOT NULL,
  fee NUMERIC NOT NULL,
  tx_hash BYTEA NOT NULL,
  block_num BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE (tx_hash)
);

CREATE TABLE IF NOT EXISTS chain_cursors (
  id TEXT PRIMARY KEY,
  last_block BIGINT NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now()
);
INSERT INTO chain_cursors (id, last_block) VALUES ('crowdfund', 0)
ON CONFLICT (id) DO NOTHING;
sql
-- go/internal/db/migrations/002_indexes.sql
CREATE INDEX IF NOT EXISTS idx_contributions_campaign ON contributions (campaign);
CREATE INDEX IF NOT EXISTS idx_contributions_contributor ON contributions (contributor);
CREATE INDEX IF NOT EXISTS idx_payouts_campaign ON payouts (campaign, milestone_idx);
CREATE INDEX IF NOT EXISTS idx_campaigns_state ON campaigns (state);
go
// go/cmd/indexer/main.go
package main

import (
    "context"
    "database/sql"
    "log"
    "math/big"
    "os"
    "os/signal"
    "strings"
    "syscall"
    "time"

    "github.com/ethereum/go-ethereum"
    "github.com/ethereum/go-ethereum/accounts/abi"
    "github.com/ethereum/go-ethereum/common"
    gethtypes "github.com/ethereum/go-ethereum/core/types"

    "github.com/yourorg/crowdfund-monorepo/go/internal/db"
    "github.com/yourorg/crowdfund-monorepo/go/internal/rpc"
)

const cursorID = "crowdfund"

func main() {
    // env
    rpcURL := mustEnv("RPC_URL")
    dsn := mustEnv("POSTGRES_DSN")
    confirms := mustEnvInt("CONFIRMATIONS", 12)
    startBlock := mustEnvUint64("START_BLOCK", 0)

    ec := rpc.MustEthClient(rpcURL)
    sqlDB := db.MustOpen(dsn)
    defer sqlDB.Close()

    implABI := mustParseABI(`[
        {"anonymous":false,"inputs":[{"indexed":true,"name":"user","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Contributed","type":"event"},
        {"anonymous":false,"inputs":[{"indexed":false,"name":"state","type":"uint8"}],"name":"Finalized","type":"event"},
        {"anonymous":false,"inputs":[{"indexed":true,"name":"user","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Refunded","type":"event"},
        {"anonymous":false,"inputs":[{"indexed":false,"name":"idx","type":"uint256"},{"indexed":false,"name":"netAmount","type":"uint256"},{"indexed":false,"name":"fee","type":"uint256"}],"name":"MilestoneExecuted","type":"event"}
    ]`)

    last := getCursor(sqlDB, startBlock)
    ticker := time.NewTicker(3 * time.Second)
    defer ticker.Stop()

    sigs := make(chan os.Signal, 1)
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

    for {
        select {
        case <-ticker.C:
            ctx, cancel := context.WithTimeout(context.Background(), 20*time.Second)
            head, err := ec.BlockNumber(ctx)
            cancel()
            if err != nil { log.Printf("head err: %v", err); continue }
            if head <= uint64(confirms) { continue }
            safe := head - uint64(confirms)
            next := last + 1
            if next == 0 || next > safe { continue }

            q := ethereum.FilterQuery{
                FromBlock: big.NewInt(int64(next)),
                ToBlock:   big.NewInt(int64(safe)),
                // Addresses: []common.Address{...} // optional: restrict to known campaigns
            }
            ctx, cancel = context.WithTimeout(context.Background(), 25*time.Second)
            logs, err := ec.FilterLogs(ctx, q)
            cancel()
            if err != nil { log.Printf("filter err: %v", err); continue }

            if err := process(sqlDB, implABI, logs); err != nil {
                log.Printf("process err: %v", err)
                continue
            }
            last = safe
            setCursor(sqlDB, safe)
        case <-sigs:
            return
        }
    }
}

func process(dbx *sql.DB, a abi.ABI, logs []gethtypes.Log) error {
    tx, err := dbx.Begin()
    if err != nil { return err }
    defer func() { if err != nil { _ = tx.Rollback() } }()

    for _, l := range logs {
        if len(l.Topics) == 0 { continue }
        switch l.Topics[0] {
        case a.Events["Contributed"].ID:
            var ev struct{ User common.Address; Amount *big.Int }
            if err = a.UnpackIntoInterface(&ev, "Contributed", l.Data); err != nil { return err }
            _, err = tx.Exec(`INSERT INTO contributions (campaign, contributor, amount, tx_hash, log_index, block_num) VALUES ($1,$2,$3,$4,$5,$6)
                ON CONFLICT (tx_hash, log_index) DO NOTHING`,
                l.Address.Bytes(), ev.User.Bytes(), ev.Amount.String(), l.TxHash.Bytes(), l.Index, l.BlockNumber)
            if err != nil { return err }

        case a.Events["Finalized"].ID:
            _, err = tx.Exec(`UPDATE campaigns SET state=$1 WHERE address=$2`, 1, l.Address.Bytes())
            if err != nil { return err }

        case a.Events["Refunded"].ID:
            // optional: mark refunded state; in minimal skeleton we skip

        case a.Events["MilestoneExecuted"].ID:
            var ev struct{ Idx, NetAmount, Fee *big.Int }
            if err = a.UnpackIntoInterface(&ev, "MilestoneExecuted", l.Data); err != nil { return err }
            _, err = tx.Exec(`INSERT INTO payouts (campaign, milestone_idx, net_amount, fee, tx_hash, block_num)
                VALUES ($1,$2,$3,$4,$5,$6) ON CONFLICT (tx_hash) DO NOTHING`,
                l.Address.Bytes(), ev.Idx.Int64(), ev.NetAmount.String(), ev.Fee.String(), l.TxHash.Bytes(), l.BlockNumber)
            if err != nil { return err }
        }
    }
    return tx.Commit()
}

func getCursor(dbx *sql.DB, defaultBlock uint64) uint64 {
    var last sql.NullInt64
    _ = dbx.QueryRow(`SELECT last_block FROM chain_cursors WHERE id=$1`, cursorID).Scan(&last)
    if last.Valid { return uint64(last.Int64) }
    _, _ = dbx.Exec(`INSERT INTO chain_cursors (id, last_block) VALUES ($1,$2)`, cursorID, defaultBlock)
    return defaultBlock
}
func setCursor(dbx *sql.DB, b uint64) {
    _, _ = dbx.Exec(`UPDATE chain_cursors SET last_block=$1, updated_at=now() WHERE id=$2`, b, cursorID)
}

func mustParseABI(jsonABI string) abi.ABI {
    ab, err := abi.JSON(strings.NewReader(jsonABI))
    if err != nil { panic(err) }
    return ab
}
func mustEnv(k string) string { v := os.Getenv(k); if v == "" { panic("missing env " + k) } ; return v }
func mustEnvInt(k string, def int) int { v := os.Getenv(k); if v == "" { return def }; i, _ := strconv.Atoi(v); return i }
func mustEnvUint64(k string, def uint64) uint64 { v := os.Getenv(k); if v == "" { return def }; u, _ := strconv.ParseUint(v, 10, 64); return u }
Devops and quickstart
yaml
# deploy/docker-compose.yml
version: "3.9"
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: crowdfund
    ports: [ "5432:5432" ]
    volumes: [ "pg:/var/lib/postgresql/data" ]

  indexer:
    build:
      context: ..
      dockerfile: Dockerfile.indexer
    env_file: ./.env
    depends_on: [ db ]
    restart: unless-stopped

volumes:
  pg: {}
dockerfile
# Dockerfile.indexer at repo root
FROM golang:1.22 AS build
WORKDIR /app
COPY go/go.mod go/go.sum ./go/
RUN cd go && go mod download
COPY go ./go
RUN cd go && go build -o /bin/indexer ./cmd/indexer

FROM debian:stable-slim
ENV TZ=UTC
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=build /bin/indexer /usr/local/bin/indexer
ENTRYPOINT ["/usr/local/bin/indexer"]
bash
# scripts/abigen.sh
#!/usr/bin/env bash
set -euo pipefail
pushd contracts >/dev/null
forge build
popd >/dev/null
pushd go >/dev/null
make build-bindings
popd >/dev/null
echo "Bindings generated."
md
<!-- README.md -->
# Crowdfund (Arbitrum + USDC) Monorepo

## Quickstart
1. Copy env
   - cp deploy/.env.example deploy/.env
   - fill RPC_URL, PRIVATE_KEY, USDC_ADDRESS
2. Deploy contracts (Arbitrum Sepolia)
   - cd contracts
   - forge script script/Deploy.s.sol:DeployCrowdfund --rpc-url $RPC_URL --broadcast --private-key $PRIVATE_KEY -vvvv
   - record Implementation and Factory addresses
3. Generate Go bindings
   - ./scripts/abigen.sh
4. Run DB and indexer
   - cd deploy && docker-compose up -d
   - export POSTGRES_DSN=postgres://postgres:postgres@localhost:5432/crowdfund?sslmode=disable
   - export RPC_URL=...
   - go run go/cmd/indexer/main.go
5. Create a campaign
   - Use Foundry/ethers script to call Factory.createCampaign(owner, USDC, softCap, hardCap, deadline, feeBps, feeReceiver)

## Notes
- Snapshot-based voting: weight equals contribution at finalize.
- Fees are taken on each milestone release.
- For production: add OZ SafeERC20, ReentrancyGuard, AccessControl, multisig + timelock.
å¦‚æœä½ æŠŠè¿™ä¸ªç»“æ„ç›´æ¥æ”¾è¿›ä»“åº“ï¼Œæ”¹å¥½ .envï¼Œå°±èƒ½åœ¨ Arbitrum Sepolia è·‘é€šéƒ¨ç½²ã€å‡ºèµ„ã€finalizeã€é‡Œç¨‹ç¢‘é‡Šæ”¾ä¸ç´¢å¼•å…¥åº“çš„å…¨é“¾è·¯ã€‚éœ€è¦æˆ‘æŠŠ Factory.createCampaign çš„ Foundryäº¤äº’è„šæœ¬å’Œä¸€ä»½æœ€å°çš„å‰ç«¯é’±åŒ…äº¤äº’é¡µé¢ä¹Ÿè¡¥ä¸Šå—ï¼Ÿ

è¡¥ä¸Š
å¥½ï¼Œé‚£æˆ‘ç›´æ¥æŠŠ Factory.createCampaign çš„ Foundry äº¤äº’è„šæœ¬ å’Œä¸€ä¸ªæœ€å°å¯ç”¨çš„ å‰ç«¯é’±åŒ…äº¤äº’é¡µé¢ è¡¥åˆ°è¿™ä¸ª monorepo é‡Œï¼Œè¿™æ ·ä½ æœ¬åœ°å°±èƒ½ä»éƒ¨ç½²åˆ°é“¾ä¸Šäº¤äº’å…¨é“¾è·¯æ‰“é€šã€‚

1ï¸âƒ£ Foundry äº¤äº’è„šæœ¬ï¼ˆåˆ›å»ºä¼—ç­¹æ´»åŠ¨ï¼‰
åœ¨ contracts/script/ ä¸‹æ–°å¢ CreateCampaign.s.solï¼š

solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import "../src/CrowdfundFactory.sol";

contract CreateCampaign is Script {
    function run() external {
        uint256 pk = vm.envUint("PRIVATE_KEY");
        address factoryAddr = vm.envAddress("FACTORY_ADDRESS");
        address usdcAddr = vm.envAddress("USDC_ADDRESS");

        vm.startBroadcast(pk);

        CrowdfundFactory factory = CrowdfundFactory(factoryAddr);

        // å‚æ•°ç¤ºä¾‹
        address owner = vm.addr(pk);
        uint256 softCap = 1_000e6; // 1000 USDC (6 decimals)
        uint256 hardCap = 10_000e6; // 10000 USDC
        uint64 deadline = uint64(block.timestamp + 7 days);
        uint16 feeBps = 300; // 3%
        address feeReceiver = owner;

        address campaign = factory.createCampaign(
            owner,
            usdcAddr,
            softCap,
            hardCap,
            deadline,
            feeBps,
            feeReceiver
        );

        console2.log("New Campaign:", campaign);

        vm.stopBroadcast();
    }
}
è¿è¡Œæ–¹å¼ï¼š

bash
forge script script/CreateCampaign.s.sol:CreateCampaign \
  --rpc-url $RPC_URL \
  --broadcast \
  --private-key $PRIVATE_KEY \
  -vvvv
2ï¸âƒ£ æœ€å°å‰ç«¯é’±åŒ…äº¤äº’é¡µé¢
åœ¨ monorepo æ–°å¢ frontend/ï¼ˆNext.js + wagmi + viemï¼‰ï¼š

ä»£ç 
frontend/
â”œâ”€ pages/
â”‚  â””â”€ index.tsx
â”œâ”€ package.json
â”œâ”€ tsconfig.json
â””â”€ ...
å®‰è£…ä¾èµ–

bash
cd frontend
npm install next react react-dom wagmi viem ethers
pages/index.tsx

tsx
import { useState } from "react";
import { useAccount, useConnect, useDisconnect, useContractWrite, usePrepareContractWrite } from "wagmi";
import { InjectedConnector } from "wagmi/connectors/injected";
import CrowdfundFactoryAbi from "../abi/CrowdfundFactory.json";

export default function Home() {
  const { address, isConnected } = useAccount();
  const { connect } = useConnect({ connector: new InjectedConnector() });
  const { disconnect } = useDisconnect();

  const [softCap, setSoftCap] = useState("1000000"); // 1 USDC (6 decimals)
  const [hardCap, setHardCap] = useState("5000000"); // 5 USDC
  const [deadline, setDeadline] = useState(Math.floor(Date.now()/1000) + 86400); // +1 day

  const { config } = usePrepareContractWrite({
    address: process.env.NEXT_PUBLIC_FACTORY_ADDRESS as `0x${string}`,
    abi: CrowdfundFactoryAbi,
    functionName: "createCampaign",
    args: [
      address,
      process.env.NEXT_PUBLIC_USDC_ADDRESS,
      BigInt(softCap),
      BigInt(hardCap),
      BigInt(deadline),
      300, // feeBps
      address
    ],
    enabled: isConnected && !!address
  });

  const { write } = useContractWrite(config);

  return (
    <div style={{ padding: 20 }}>
      <h1>ä¼—ç­¹æ´»åŠ¨åˆ›å»º</h1>
      {!isConnected ? (
        <button onClick={() => connect()}>è¿æ¥é’±åŒ…</button>
      ) : (
        <div>
          <p>å·²è¿æ¥: {address}</p>
          <button onClick={() => disconnect()}>æ–­å¼€</button>
        </div>
      )}

      <div>
        <label>Soft Cap (USDC, 6 decimals):</label>
        <input value={softCap} onChange={e => setSoftCap(e.target.value)} />
      </div>
      <div>
        <label>Hard Cap (USDC, 6 decimals):</label>
        <input value={hardCap} onChange={e => setHardCap(e.target.value)} />
      </div>
      <div>
        <label>Deadline (unix timestamp):</label>
        <input value={deadline} onChange={e => setDeadline(Number(e.target.value))} />
      </div>

      <button disabled={!write} onClick={() => write?.()}>
        åˆ›å»ºæ´»åŠ¨
      </button>
    </div>
  );
}
abi/CrowdfundFactory.json

ä» contracts/out/CrowdfundFactory.sol/CrowdfundFactory.abi.json å¤åˆ¶åˆ° frontend/abi/ã€‚

è¿è¡Œ

bash
NEXT_PUBLIC_FACTORY_ADDRESS=0xYourFactory \
NEXT_PUBLIC_USDC_ADDRESS=0xYourUSDC \
npm run dev
3ï¸âƒ£ é“¾è·¯è¯´æ˜
éƒ¨ç½²é˜¶æ®µï¼šç”¨ Deploy.s.sol éƒ¨ç½² Implementation + Factory

åˆ›å»ºæ´»åŠ¨ï¼šå¯ç”¨ CreateCampaign.s.solï¼ˆé“¾ä¸‹è„šæœ¬ï¼‰æˆ–å‰ç«¯é¡µé¢ï¼ˆé“¾ä¸Šäº¤æ˜“ï¼‰

ç´¢å¼•å™¨ï¼šGo æœåŠ¡ç›‘å¬ CampaignCreated äº‹ä»¶ï¼Œå…¥åº“æ´»åŠ¨ä¿¡æ¯

äº¤äº’ï¼šå‰ç«¯å¯æ‰©å±•è´¡çŒ®ã€æŠ•ç¥¨ã€é‡Šæ”¾ç­‰åŠŸèƒ½ï¼Œç›´æ¥è°ƒç”¨ Implementation åˆçº¦ ABI

æˆ‘å¯ä»¥å¸®ä½ æŠŠè¿™ä¸ª frontend ç›®å½•ç›´æ¥å¹¶å…¥ä¹‹å‰çš„ monorepo æ–‡ä»¶æ ‘ï¼Œå¹¶åŠ ä¸Šä¸€ä¸ª è´¡çŒ®/æŠ•ç¥¨/é€€æ¬¾ çš„äº¤äº’é¡µé¢ï¼Œè¿™æ ·ä½ å°±æœ‰ä¸€ä¸ªå®Œæ•´çš„ DApp åŸå‹ã€‚ ä½ è¦æˆ‘æŠŠè¿™ä¸‰ä¸ªäº¤äº’åŠŸèƒ½ä¹Ÿè¡¥ä¸Šå—ï¼Œè¿™æ ·å‰ç«¯å°±èƒ½å…¨æµç¨‹æ“ä½œä¼—ç­¹æ´»åŠ¨äº†ï¼Ÿ

éœ€è¦
å¥½ï¼Œé‚£æˆ‘ç›´æ¥æŠŠ è´¡çŒ® / æŠ•ç¥¨ / é€€æ¬¾ ä¸‰ä¸ªäº¤äº’åŠŸèƒ½è¡¥åˆ°å‰ç«¯ï¼Œè®©ä½ è¿™ä¸ª DApp åŸå‹å¯ä»¥å…¨æµç¨‹æ“ä½œä¼—ç­¹æ´»åŠ¨ã€‚æˆ‘ä»¬ä¼šåœ¨ frontend/pages/index.tsx åŸºç¡€ä¸Šæ‰©å±•ï¼Œå¹¶ä¸”æ‹†æˆå‡ ä¸ªå°ç»„ä»¶ï¼Œæ–¹ä¾¿ç»´æŠ¤ã€‚

1ï¸âƒ£ å‰ç«¯ç›®å½•ç»“æ„ï¼ˆæ‰©å±•ç‰ˆï¼‰
ä»£ç 
frontend/
â”œâ”€ abi/
â”‚  â”œâ”€ CrowdfundFactory.json
â”‚  â””â”€ CrowdfundImplementation.json
â”œâ”€ components/
â”‚  â”œâ”€ CreateCampaignForm.tsx
â”‚  â”œâ”€ ContributeForm.tsx
â”‚  â”œâ”€ VoteForm.tsx
â”‚  â””â”€ RefundButton.tsx
â”œâ”€ pages/
â”‚  â””â”€ index.tsx
â”œâ”€ package.json
â””â”€ ...
2ï¸âƒ£ ABI å‡†å¤‡
CrowdfundImplementation.json ä» contracts/out/CrowdfundImplementation.sol/CrowdfundImplementation.abi.json å¤åˆ¶åˆ° frontend/abi/

CrowdfundFactory.json å·²æœ‰

3ï¸âƒ£ ç»„ä»¶å®ç°
CreateCampaignForm.tsx
ï¼ˆå’Œä¹‹å‰ç±»ä¼¼ï¼Œè¿™é‡Œç•¥ï¼‰

ContributeForm.tsx
tsx
import { useState } from "react";
import { useAccount, usePrepareContractWrite, useContractWrite } from "wagmi";
import CrowdfundImplAbi from "../abi/CrowdfundImplementation.json";

export default function ContributeForm({ campaignAddress, tokenIsNative }: { campaignAddress: `0x${string}`, tokenIsNative: boolean }) {
  const { address } = useAccount();
  const [amount, setAmount] = useState("0");

  const { config } = usePrepareContractWrite({
    address: campaignAddress,
    abi: CrowdfundImplAbi,
    functionName: "contribute",
    args: tokenIsNative ? [0] : [BigInt(amount)],
    overrides: tokenIsNative ? { value: BigInt(amount) } : {},
    enabled: !!address && !!campaignAddress
  });

  const { write } = useContractWrite(config);

  return (
    <div>
      <h3>è´¡çŒ®èµ„é‡‘</h3>
      <input value={amount} onChange={e => setAmount(e.target.value)} placeholder={tokenIsNative ? "ETH æ•°é‡" : "ä»£å¸æœ€å°å•ä½"} />
      <button disabled={!write} onClick={() => write?.()}>è´¡çŒ®</button>
    </div>
  );
}
VoteForm.tsx
tsx
import { useState } from "react";
import { useAccount, usePrepareContractWrite, useContractWrite } from "wagmi";
import CrowdfundImplAbi from "../abi/CrowdfundImplementation.json";

export default function VoteForm({ campaignAddress }: { campaignAddress: `0x${string}` }) {
  const { address } = useAccount();
  const [milestoneIdx, setMilestoneIdx] = useState("0");
  const [support, setSupport] = useState(true);

  const { config } = usePrepareContractWrite({
    address: campaignAddress,
    abi: CrowdfundImplAbi,
    functionName: "vote",
    args: [BigInt(milestoneIdx), support],
    enabled: !!address
  });

  const { write } = useContractWrite(config);

  return (
    <div>
      <h3>æŠ•ç¥¨</h3>
      <input value={milestoneIdx} onChange={e => setMilestoneIdx(e.target.value)} placeholder="é‡Œç¨‹ç¢‘ç´¢å¼•" />
      <label>
        <input type="checkbox" checked={support} onChange={e => setSupport(e.target.checked)} />
        æ”¯æŒ
      </label>
      <button disabled={!write} onClick={() => write?.()}>æäº¤æŠ•ç¥¨</button>
    </div>
  );
}
RefundButton.tsx
tsx
import { useAccount, usePrepareContractWrite, useContractWrite } from "wagmi";
import CrowdfundImplAbi from "../abi/CrowdfundImplementation.json";

export default function RefundButton({ campaignAddress }: { campaignAddress: `0x${string}` }) {
  const { address } = useAccount();

  const { config } = usePrepareContractWrite({
    address: campaignAddress,
    abi: CrowdfundImplAbi,
    functionName: "refund",
    enabled: !!address
  });

  const { write } = useContractWrite(config);

  return (
    <div>
      <h3>é€€æ¬¾</h3>
      <button disabled={!write} onClick={() => write?.()}>ç”³è¯·é€€æ¬¾</button>
    </div>
  );
}
4ï¸âƒ£ index.tsx æ•´åˆ
tsx
import { WagmiConfig, createConfig, configureChains } from "wagmi";
import { arbitrumSepolia } from "wagmi/chains";
import { publicProvider } from "wagmi/providers/public";
import { InjectedConnector } from "wagmi/connectors/injected";
import { useAccount, useConnect, useDisconnect } from "wagmi";
import CreateCampaignForm from "../components/CreateCampaignForm";
import ContributeForm from "../components/ContributeForm";
import VoteForm from "../components/VoteForm";
import RefundButton from "../components/RefundButton";

const { chains, publicClient, webSocketPublicClient } = configureChains(
  [arbitrumSepolia],
  [publicProvider()]
);

const config = createConfig({
  autoConnect: true,
  connectors: [new InjectedConnector({ chains })],
  publicClient,
  webSocketPublicClient
});

export default function App() {
  return (
    <WagmiConfig config={config}>
      <Main />
    </WagmiConfig>
  );
}

function Main() {
  const { address, isConnected } = useAccount();
  const { connect } = useConnect({ connector: new InjectedConnector() });
  const { disconnect } = useDisconnect();

  const campaignAddress = process.env.NEXT_PUBLIC_CAMPAIGN_ADDRESS as `0x${string}`;

  return (
    <div style={{ padding: 20 }}>
      <h1>å»ä¸­å¿ƒåŒ–ä¼—ç­¹ DApp</h1>
      {!isConnected ? (
        <button onClick={() => connect()}>è¿æ¥é’±åŒ…</button>
      ) : (
        <div>
          <p>å·²è¿æ¥: {address}</p>
          <button onClick={() => disconnect()}>æ–­å¼€</button>
        </div>
      )}

      <CreateCampaignForm />
      <ContributeForm campaignAddress={campaignAddress} tokenIsNative={false} />
      <VoteForm campaignAddress={campaignAddress} />
      <RefundButton campaignAddress={campaignAddress} />
    </div>
  );
}
5ï¸âƒ£ ä½¿ç”¨è¯´æ˜
éƒ¨ç½²åˆçº¦ï¼šç”¨ Foundry éƒ¨ç½² Implementation + Factory

åˆ›å»ºæ´»åŠ¨ï¼šç”¨ CreateCampaign.s.sol æˆ–å‰ç«¯ CreateCampaignForm

è´¡çŒ®èµ„é‡‘ï¼šContributeFormï¼ˆåŸç”Ÿå¸æˆ– USDCï¼‰

æŠ•ç¥¨ï¼šVoteFormï¼ˆè¾“å…¥é‡Œç¨‹ç¢‘ç´¢å¼•ï¼Œé€‰æ‹©æ”¯æŒ/åå¯¹ï¼‰

é€€æ¬¾ï¼šRefundButtonï¼ˆæ´»åŠ¨å¤±è´¥æ—¶å¯ç”¨ï¼‰

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥å¸®ä½ åœ¨è¿™ä¸ªå‰ç«¯é‡ŒåŠ ä¸Š å®æ—¶è¯»å–é“¾ä¸Šæ´»åŠ¨çŠ¶æ€ã€è´¡çŒ®åˆ—è¡¨ã€æŠ•ç¥¨ç»“æœ çš„ hooksï¼Œè¿™æ ·ä½ å°±èƒ½åœ¨é¡µé¢ä¸Šçœ‹åˆ°æœ€æ–°çš„ä¼—ç­¹è¿›åº¦å’ŒæŠ•ç¥¨æƒ…å†µï¼Œè€Œä¸å¿…åˆ·æ–°é¡µé¢ã€‚ è¦æˆ‘æŠŠè¿™ä¸ªé“¾ä¸Šæ•°æ®å®æ—¶å±•ç¤ºåŠŸèƒ½ä¹ŸåŠ ä¸Šå—ï¼Œè¿™æ ·å°±æˆäº†ä¸€ä¸ªå®Œæ•´çš„å¯ç”¨ DApp ä»ªè¡¨ç›˜ã€‚

å®æ—¶è¯»å–é“¾ä¸Šæ´»åŠ¨çŠ¶æ€ã€è´¡çŒ®åˆ—è¡¨ã€æŠ•ç¥¨ç»“æœ
å¥½ï¼Œé‚£æˆ‘å¸®ä½ æŠŠ å®æ—¶è¯»å–é“¾ä¸Šæ´»åŠ¨çŠ¶æ€ã€è´¡çŒ®åˆ—è¡¨ã€æŠ•ç¥¨ç»“æœ çš„åŠŸèƒ½åŠ åˆ°å‰ç«¯ï¼Œç”¨ wagmi + viem çš„ useReadContract å’Œ usePublicClient æ¥åšé“¾ä¸Šè½®è¯¢ï¼Œè¿™æ ·é¡µé¢ä¼šè‡ªåŠ¨åˆ·æ–°æ•°æ®ï¼Œä¸ç”¨æ‰‹åŠ¨ç‚¹æŒ‰é’®ã€‚

1ï¸âƒ£ æ–°å¢ hooksï¼ˆfrontend/hooks/useCampaignData.tsï¼‰
ts
import { useEffect, useState } from "react";
import { usePublicClient } from "wagmi";
import CrowdfundImplAbi from "../abi/CrowdfundImplementation.json";

export function useCampaignData(campaignAddress: `0x${string}`) {
  const publicClient = usePublicClient();
  const [state, setState] = useState<number>();
  const [totalRaised, setTotalRaised] = useState<string>();
  const [milestones, setMilestones] = useState<any[]>([]);

  useEffect(() => {
    if (!campaignAddress) return;
    let timer: NodeJS.Timer;

    async function fetchData() {
      try {
        const s = await publicClient.readContract({
          address: campaignAddress,
          abi: CrowdfundImplAbi,
          functionName: "state"
        });
        setState(Number(s));

        const raised = await publicClient.readContract({
          address: campaignAddress,
          abi: CrowdfundImplAbi,
          functionName: "totalRaised"
        });
        setTotalRaised(raised.toString());

        const count = await publicClient.readContract({
          address: campaignAddress,
          abi: CrowdfundImplAbi,
          functionName: "milestonesCount"
        });

        const ms: any[] = [];
        for (let i = 0; i < Number(count); i++) {
          const m = await publicClient.readContract({
            address: campaignAddress,
            abi: CrowdfundImplAbi,
            functionName: "milestones",
            args: [BigInt(i)]
          });
          ms.push(m);
        }
        setMilestones(ms);
      } catch (err) {
        console.error(err);
      }
    }

    fetchData();
    timer = setInterval(fetchData, 5000); // æ¯ 5 ç§’åˆ·æ–°ä¸€æ¬¡
    return () => clearInterval(timer);
  }, [campaignAddress]);

  return { state, totalRaised, milestones };
}
2ï¸âƒ£ è¯»å–è´¡çŒ®åˆ—è¡¨ï¼ˆfrontend/hooks/useContributions.tsï¼‰
è´¡çŒ®åˆ—è¡¨æ˜¯äº‹ä»¶æ•°æ®ï¼Œé“¾ä¸Šä¸ç›´æ¥å­˜æ•°ç»„ï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨ getLogs ä»äº‹ä»¶é‡Œè§£æã€‚

ts
import { useEffect, useState } from "react";
import { usePublicClient } from "wagmi";
import { parseAbiItem } from "viem";

export function useContributions(campaignAddress: `0x${string}`) {
  const publicClient = usePublicClient();
  const [contribs, setContribs] = useState<any[]>([]);

  useEffect(() => {
    if (!campaignAddress) return;
    let timer: NodeJS.Timer;

    async function fetchLogs() {
      try {
        const logs = await publicClient.getLogs({
          address: campaignAddress,
          event: parseAbiItem(
            "event Contributed(address indexed user, uint256 amount)"
          ),
          fromBlock: BigInt(0),
          toBlock: "latest"
        });
        const parsed = logs.map(l => ({
          user: l.args?.user,
          amount: l.args?.amount?.toString()
        }));
        setContribs(parsed);
      } catch (err) {
        console.error(err);
      }
    }

    fetchLogs();
    timer = setInterval(fetchLogs, 10000);
    return () => clearInterval(timer);
  }, [campaignAddress]);

  return contribs;
}
3ï¸âƒ£ è¯»å–æŠ•ç¥¨ç»“æœï¼ˆfrontend/hooks/useVotes.tsï¼‰
ts
import { useEffect, useState } from "react";
import { usePublicClient } from "wagmi";
import { parseAbiItem } from "viem";

export function useVotes(campaignAddress: `0x${string}`, milestoneIdx: number) {
  const publicClient = usePublicClient();
  const [votes, setVotes] = useState<{ forVotes: string; againstVotes: string }>({ forVotes: "0", againstVotes: "0" });

  useEffect(() => {
    if (!campaignAddress) return;
    let timer: NodeJS.Timer;

    async function fetchVotes() {
      try {
        const logs = await publicClient.getLogs({
          address: campaignAddress,
          event: parseAbiItem(
            "event Voted(uint256 indexed idx, address indexed voter, bool support, uint256 weight)"
          ),
          fromBlock: BigInt(0),
          toBlock: "latest",
          args: { idx: BigInt(milestoneIdx) }
        });

        let forSum = BigInt(0);
        let againstSum = BigInt(0);
        logs.forEach(l => {
          if (l.args?.support) forSum += BigInt(l.args?.weight || 0);
          else againstSum += BigInt(l.args?.weight || 0);
        });

        setVotes({ forVotes: forSum.toString(), againstVotes: againstSum.toString() });
      } catch (err) {
        console.error(err);
      }
    }

    fetchVotes();
    timer = setInterval(fetchVotes, 10000);
    return () => clearInterval(timer);
  }, [campaignAddress, milestoneIdx]);

  return votes;
}
4ï¸âƒ£ åœ¨é¡µé¢ä¸­å±•ç¤ºå®æ—¶æ•°æ®
tsx
import { useCampaignData } from "../hooks/useCampaignData";
import { useContributions } from "../hooks/useContributions";
import { useVotes } from "../hooks/useVotes";

export default function Dashboard({ campaignAddress }: { campaignAddress: `0x${string}` }) {
  const { state, totalRaised, milestones } = useCampaignData(campaignAddress);
  const contributions = useContributions(campaignAddress);
  const votes = useVotes(campaignAddress, 0); // é‡Œç¨‹ç¢‘ 0

  return (
    <div>
      <h2>æ´»åŠ¨çŠ¶æ€: {state}</h2>
      <p>å·²ç­¹é›†: {totalRaised}</p>

      <h3>è´¡çŒ®åˆ—è¡¨</h3>
      <ul>
        {contributions.map((c, i) => (
          <li key={i}>{c.user} - {c.amount}</li>
        ))}
      </ul>

      <h3>é‡Œç¨‹ç¢‘ 0 æŠ•ç¥¨ç»“æœ</h3>
      <p>æ”¯æŒç¥¨: {votes.forVotes}</p>
      <p>åå¯¹ç¥¨: {votes.againstVotes}</p>

      <h3>é‡Œç¨‹ç¢‘åˆ—è¡¨</h3>
      <ul>
        {milestones.map((m, i) => (
          <li key={i}>
            é‡‘é¢: {m[0].toString()} CID: {m[1]} æ‰§è¡Œ: {m[6] ? "æ˜¯" : "å¦"}
          </li>
        ))}
      </ul>
    </div>
  );
}
âœ… è¿™æ ·å‰ç«¯ä¼šè‡ªåŠ¨è½®è¯¢é“¾ä¸Šæ•°æ®ï¼Œå®æ—¶æ˜¾ç¤ºæ´»åŠ¨çŠ¶æ€ã€è´¡çŒ®è®°å½•å’ŒæŠ•ç¥¨ç»“æœã€‚ å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥å¸®ä½ æŠŠè¿™ä¸ª Dashboard å’Œä¹‹å‰çš„ åˆ›å»º/è´¡çŒ®/æŠ•ç¥¨/é€€æ¬¾ é¡µé¢åˆå¹¶æˆä¸€ä¸ªå®Œæ•´çš„ ä¼—ç­¹æ´»åŠ¨è¯¦æƒ…é¡µï¼Œå¹¶åŠ ä¸Š äº‹ä»¶ç›‘å¬ï¼ˆwatchContractEventï¼‰ æ¥åšåˆ°ç§’çº§å®æ—¶æ›´æ–°ï¼Œä¸å¿…è½®è¯¢ã€‚

è¦æˆ‘å¸®ä½ æŠŠå®ƒå‡çº§æˆ äº‹ä»¶é©±åŠ¨çš„å®æ—¶ DApp å—ï¼Ÿè¿™æ ·ä½“éªŒä¼šæ›´ä¸æ»‘ã€‚

æŠŠå®ƒå‡çº§æˆ äº‹ä»¶é©±åŠ¨çš„å®æ—¶ DApp
Event-driven realtime dApp upgrade
ä¸‹é¢æ˜¯ä¸€å¥—å¯ç›´æ¥è½åœ°çš„æ”¹é€ æ–¹æ¡ˆä¸ä»£ç éª¨æ¶ï¼Œå°†è½®è¯¢å¼è¯»å–å‡çº§ä¸ºäº‹ä»¶é©±åŠ¨ã€å‡†å®æ—¶ä¸”å…·å¤‡é‡ç»„å›æ»šä¸æ–­çº¿æ¢å¤èƒ½åŠ›çš„ DAppã€‚æ ¸å¿ƒç‚¹ï¼šå¯ç”¨ WebSocketã€ä½¿ç”¨äº‹ä»¶è®¢é˜…å¢é‡æ›´æ–°æœ¬åœ°çŠ¶æ€ã€å¤„ç†é“¾ä¸Šé‡ç»„ã€ä¸åç«¯ç´¢å¼•å™¨å½¢æˆåŒé€šé“å†—ä½™ã€‚

Transport ä¸å…¨å±€çŠ¶æ€
1) å¯ç”¨ WebSocket transportï¼ˆwagmi + viemï¼‰
tsx
// frontend/lib/wagmi.ts
import { WagmiConfig, createConfig, configureChains } from 'wagmi'
import { arbitrumSepolia } from 'wagmi/chains'
import { webSocket, http } from 'viem'
import { InjectedConnector } from 'wagmi/connectors/injected'

const WS_URL = process.env.NEXT_PUBLIC_WS_URL!     // wss://arb-sepolia.g.alchemy.com/v2/...
const RPC_URL = process.env.NEXT_PUBLIC_RPC_URL!   // https://...

export const config = createConfig({
  autoConnect: true,
  chains: [arbitrumSepolia],
  transports: {
    [arbitrumSepolia.id]: webSocket(WS_URL), // ä¸»ç”¨ WS
  },
  // å¯é€‰ï¼šHTTP å¤‡ç”¨
  // transports: { [arbitrumSepolia.id]: http(RPC_URL) }
})

export function AppProviders({ children }: { children: React.ReactNode }) {
  return <WagmiConfig config={config}>{children}</WagmiConfig>
}
åœ¨ pages/_app.tsx ä¸­åŒ…è£¹ AppProvidersã€‚

2) ç»Ÿä¸€çš„å‰ç«¯ Storeï¼ˆZustandï¼‰
ts
// frontend/store/campaign.ts
import { create } from 'zustand'

type Contribution = { user: `0x${string}`, amount: bigint, tx?: `0x${string}` }
type VoteAgg = { forVotes: bigint, againstVotes: bigint }
type Milestone = {
  amount: bigint, proofCid: string, voteStart: bigint, voteEnd: bigint,
  forVotes: bigint, againstVotes: bigint, executed: boolean
}

type State = {
  state?: number
  totalRaised: bigint
  contributions: Contribution[]
  milestones: Record<number, Milestone>
  lastBlock: bigint
}
type Actions = {
  init: (s: Partial<State>) => void
  applyContributed: (c: Contribution, block: bigint, removed?: boolean) => void
  applyVoted: (idx: number, weight: bigint, support: boolean, block: bigint, removed?: boolean) => void
  applyExecuted: (idx: number, net: bigint, fee: bigint, block: bigint, removed?: boolean) => void
  setState: (st: number) => void
}

export const useCampaignStore = create<State & Actions>((set, get) => ({
  totalRaised: 0n,
  contributions: [],
  milestones: {},
  lastBlock: 0n,

  init: (s) => set({ ...s }),

  applyContributed: (c, block, removed) => {
    const st = get()
    if (removed) {
      // å›æ»šï¼šä»åˆ—è¡¨å›æ’¤ï¼Œå‡å°‘ totalRaised
      const idx = st.contributions.findIndex(x => x.tx === c.tx)
      if (idx >= 0) {
        const amt = st.contributions[idx].amount
        const next = st.contributions.slice()
        next.splice(idx, 1)
        set({
          contributions: next,
          totalRaised: st.totalRaised - amt,
          lastBlock: block > st.lastBlock ? block : st.lastBlock
        })
      }
      return
    }
    set({
      contributions: [...st.contributions, c],
      totalRaised: st.totalRaised + c.amount,
      lastBlock: block > st.lastBlock ? block : st.lastBlock
    })
  },

  applyVoted: (idx, weight, support, block, removed) => {
    const st = get()
    const m = st.milestones[idx] || {
      amount: 0n, proofCid: '', voteStart: 0n, voteEnd: 0n,
      forVotes: 0n, againstVotes: 0n, executed: false
    }
    const delta = removed ? -weight : weight
    const next: Milestone = {
      ...m,
      forVotes: support ? (m.forVotes + delta) : m.forVotes,
      againstVotes: !support ? (m.againstVotes + delta) : m.againstVotes,
    }
    set({
      milestones: { ...st.milestones, [idx]: next },
      lastBlock: block > st.lastBlock ? block : st.lastBlock
    })
  },

  applyExecuted: (idx, net, fee, block, removed) => {
    const st = get()
    const m = st.milestones[idx] || {
      amount: 0n, proofCid: '', voteStart: 0n, voteEnd: 0n,
      forVotes: 0n, againstVotes: 0n, executed: false
    }
    const next: Milestone = { ...m, executed: !removed } // é‡ç»„æ’¤å›
    set({
      milestones: { ...st.milestones, [idx]: next },
      lastBlock: block > st.lastBlock ? block : st.lastBlock
    })
  },

  setState: (stt) => set({ state: stt })
}))
Event è®¢é˜…ä¸å¢é‡åŒæ­¥
1) åˆçº¦äº‹ä»¶ watchï¼ˆå«é‡ç»„å¤„ç†ï¼‰
ts
// frontend/hooks/useCampaignLive.ts
import { useEffect } from 'react'
import { usePublicClient } from 'wagmi'
import { parseAbiItem } from 'viem'
import { useCampaignStore } from '../store/campaign'

const E = {
  Contributed: parseAbiItem("event Contributed(address indexed user, uint256 amount)"),
  Finalized: parseAbiItem("event Finalized(uint8 state)"),
  Voted: parseAbiItem("event Voted(uint256 indexed idx, address indexed voter, bool support, uint256 weight)"),
  MilestoneExecuted: parseAbiItem("event MilestoneExecuted(uint256 indexed idx, uint256 netAmount, uint256 fee)"),
  Refunded: parseAbiItem("event Refunded(address indexed user, uint256 amount)")
}

export function useCampaignLive(campaign: `0x${string}`) {
  const pc = usePublicClient()
  const applyContributed = useCampaignStore(s => s.applyContributed)
  const applyVoted = useCampaignStore(s => s.applyVoted)
  const applyExecuted = useCampaignStore(s => s.applyExecuted)
  const setState = useCampaignStore(s => s.setState)

  useEffect(() => {
    if (!campaign) return
    const unsubs: Array<() => void> = []

    // Contributed
    const u1 = pc.watchContractEvent({
      address: campaign,
      event: E.Contributed,
      onLogs(logs) {
        logs.forEach(l => {
          const removed = l.removed === true
          applyContributed(
            { user: l.args!.user as `0x${string}`, amount: l.args!.amount as bigint, tx: l.transactionHash },
            BigInt(l.blockNumber!), removed
          )
        })
      }
    }); unsubs.push(u1)

    // Finalized
    const u2 = pc.watchContractEvent({
      address: campaign,
      event: E.Finalized,
      onLogs(logs) {
        logs.forEach(l => {
          const st = Number(l.args!.state)
          // å¦‚æœ removedï¼Œåˆ™å¯ä»¥å›é€€åˆ°ä¸Šä¸€ä¸ª stateï¼›æ­¤å¤„ç®€åŒ–ä¸ºè¦†ç›–
          setState(st)
        })
      }
    }); unsubs.push(u2)

    // Voted
    const u3 = pc.watchContractEvent({
      address: campaign,
      event: E.Voted,
      onLogs(logs) {
        logs.forEach(l => {
          const removed = l.removed === true
          const idx = Number(l.args!.idx)
          const support = Boolean(l.args!.support)
          const weight = l.args!.weight as bigint
          applyVoted(idx, weight, support, BigInt(l.blockNumber!), removed)
        })
      }
    }); unsubs.push(u3)

    // MilestoneExecuted
    const u4 = pc.watchContractEvent({
      address: campaign,
      event: E.MilestoneExecuted,
      onLogs(logs) {
        logs.forEach(l => {
          const removed = l.removed === true
          const idx = Number(l.args!.idx)
          const net = l.args!.netAmount as bigint
          const fee = l.args!.fee as bigint
          applyExecuted(idx, net, fee, BigInt(l.blockNumber!), removed)
        })
      }
    }); unsubs.push(u4)

    // Refundedï¼ˆå¯ç”¨äº UI æç¤ºï¼‰
    const u5 = pc.watchContractEvent({
      address: campaign,
      event: E.Refunded,
      onLogs(logs) {
        // å¯åœ¨æ­¤è§¦å‘ toastï¼Œæˆ–æ›´æ–°æœ¬åœ°â€œæˆ‘å·²é€€æ¬¾â€çš„çŠ¶æ€
      }
    }); unsubs.push(u5)

    return () => unsubs.forEach(u => u())
  }, [campaign])
}
è¦ç‚¹ï¼š

äº‹ä»¶å¯¹è±¡çš„ removed æ ‡è®°ç”¨äºå¤„ç†é“¾ä¸Šé‡ç»„å›æ»šï¼Œç¡®ä¿æœ¬åœ°çŠ¶æ€å¯é€†ã€‚

ä¸å†è½®è¯¢åˆçº¦çŠ¶æ€ï¼Œæ”¹ä¸ºäº‹ä»¶é©±åŠ¨å¢é‡æ›´æ–°ï¼›åˆæ¬¡åŠ è½½ä»å»ºè®®åšä¸€æ¬¡æ€§å¿«ç…§ï¼ˆè§ä¸‹ï¼‰ã€‚

2) åˆæ¬¡å¿«ç…§ + äº‹ä»¶æ¥ç®¡
ts
// frontend/hooks/useCampaignSnapshot.ts
import { useEffect } from 'react'
import { usePublicClient } from 'wagmi'
import CrowdfundImplAbi from '../abi/CrowdfundImplementation.json'
import { useCampaignStore } from '../store/campaign'

export function useCampaignSnapshot(campaign: `0x${string}`) {
  const pc = usePublicClient()
  const init = useCampaignStore(s => s.init)

  useEffect(() => {
    if (!campaign) return
    let cancel = false

    async function load() {
      try {
        const [state, totalRaised, count] = await Promise.all([
          pc.readContract({ address: campaign, abi: CrowdfundImplAbi, functionName: 'state' }),
          pc.readContract({ address: campaign, abi: CrowdfundImplAbi, functionName: 'totalRaised' }),
          pc.readContract({ address: campaign, abi: CrowdfundImplAbi, functionName: 'milestonesCount' })
        ])
        const milestones: any = {}
        for (let i = 0; i < Number(count); i++) {
          const m: any = await pc.readContract({ address: campaign, abi: CrowdfundImplAbi, functionName: 'milestones', args: [BigInt(i)] })
          milestones[i] = {
            amount: m[0] as bigint, proofCid: m[1] as string,
            voteStart: m[2] as bigint, voteEnd: m[3] as bigint,
            forVotes: m[4] as bigint, againstVotes: m[5] as bigint,
            executed: m[6] as boolean
          }
        }
        if (!cancel) init({
          state: Number(state),
          totalRaised: totalRaised as bigint,
          milestones
        })
      } catch (e) { console.error(e) }
    }

    load()
    return () => { cancel = true }
  }, [campaign])
}
åœ¨é¡µé¢ä¸­ï¼šé¦–æ¬¡ mount å…ˆ useCampaignSnapshot æ‹‰å…¨é‡ï¼Œéšå useCampaignLive è®¢é˜…å¢é‡äº‹ä»¶ã€‚

UI ç»„ä»¶æ¥å…¥ï¼ˆå®æ—¶ä»ªè¡¨ç›˜ï¼‰
tsx
// frontend/pages/campaign.tsx
import { useAccount } from 'wagmi'
import { useCampaignSnapshot } from '../hooks/useCampaignSnapshot'
import { useCampaignLive } from '../hooks/useCampaignLive'
import { useCampaignStore } from '../store/campaign'
import ContributeForm from '../components/ContributeForm'
import VoteForm from '../components/VoteForm'
import RefundButton from '../components/RefundButton'

const CAMPAIGN = process.env.NEXT_PUBLIC_CAMPAIGN_ADDRESS as `0x${string}`

export default function CampaignPage() {
  const { isConnected } = useAccount()
  useCampaignSnapshot(CAMPAIGN)
  useCampaignLive(CAMPAIGN)

  const state = useCampaignStore(s => s.state)
  const totalRaised = useCampaignStore(s => s.totalRaised)
  const contributions = useCampaignStore(s => s.contributions)
  const milestones = useCampaignStore(s => s.milestones)

  return (
    <div style={{ padding: 20 }}>
      <h1>ä¼—ç­¹æ´»åŠ¨å®æ—¶ä»ªè¡¨ç›˜</h1>
      <p>åˆçº¦: {CAMPAIGN}</p>
      <p>çŠ¶æ€: {state}</p>
      <p>å·²ç­¹é›†: {totalRaised.toString()}</p>

      <h3>è´¡çŒ®</h3>
      <ContributeForm campaignAddress={CAMPAIGN} tokenIsNative={false} />
      <ul>
        {contributions.slice(-10).reverse().map((c, i) =>
          <li key={i}>{c.user} +{c.amount.toString()}</li>
        )}
      </ul>

      <h3>é‡Œç¨‹ç¢‘</h3>
      <ul>
        {Object.entries(milestones).map(([idx, m]: any) => (
          <li key={idx}>
            #{idx} é‡‘é¢: {m.amount.toString()} æ‰§è¡Œ: {m.executed ? 'æ˜¯' : 'å¦'}
            <div style={{ display: 'flex', gap: 8 }}>
              <span>æ”¯æŒ: {m.forVotes.toString()}</span>
              <span>åå¯¹: {m.againstVotes.toString()}</span>
            </div>
            <VoteForm campaignAddress={CAMPAIGN} />
          </li>
        ))}
      </ul>

      <h3>é€€æ¬¾</h3>
      <RefundButton campaignAddress={CAMPAIGN} />
    </div>
  )
}
ä¸åç«¯ç´¢å¼•å™¨çš„åŒé€šé“å†—ä½™
çº¯å‰ç«¯äº‹ä»¶è®¢é˜…åœ¨ç½‘ç»œ/æµè§ˆå™¨é™åˆ¶æˆ–å†å²æ¢å¤æ—¶å­˜åœ¨ç›²ç‚¹ï¼Œå»ºè®®å‰ç«¯å¢åŠ â€œåç«¯äº‹ä»¶æ¡¥â€ä½œä¸ºå…œåº•ï¼š

å‰ç«¯é»˜è®¤ä½¿ç”¨ WebSocket è®¢é˜…é“¾ä¸Šäº‹ä»¶ã€‚

å¯åŠ¨æ—¶åšä¸€æ¬¡åç«¯å¿«ç…§åŒæ­¥ï¼ˆRESTï¼š/api/campaign/:addr/snapshotï¼‰ã€‚

æ¯ N åˆ†é’Ÿæ¯”å¯¹ä¸€æ¬¡åç«¯èšåˆï¼ˆå¯¹è´¦ï¼‰ï¼Œå‘ç°å·®å¼‚åˆ™ä»¥åç«¯ä¸ºå‡†çº åã€‚

åç«¯åœ¨é‡ç»„æ—¶æŒ‰ç…§æ¸¸æ ‡å›æ”¾ï¼Œå‰ç«¯æ”¶åˆ° SSE/WebSocket â€œreorg_rangeâ€ é€šçŸ¥åï¼Œå¯¹æŒ‡å®šåŒºå—èŒƒå›´å†…çš„æœ¬åœ°äº‹ä»¶åšæ’¤é”€å’Œé‡æ”¾ã€‚

å‰ç«¯ SSE ç¤ºä¾‹ï¼ˆå…œåº•ï¼‰ï¼š

ts
// frontend/lib/sse.ts
export function subscribeBackendEvents(campaign: string, onEvent: (e: any) => void) {
  const es = new EventSource(`/api/events?campaign=${campaign}`)
  es.onmessage = (msg) => onEvent(JSON.parse(msg.data))
  es.onerror = () => { /* å¯åšé‡è¿ */ }
  return () => es.close()
}
å¯é æ€§ä¸ä¼˜åŒ–è¦ç‚¹
é‡ç»„å¤„ç†ï¼šå·²ä½¿ç”¨ log.removed å›æ»šæœ¬åœ°çŠ¶æ€ï¼Œç¡®ä¿ä¸€è‡´æ€§ã€‚

æ–­çº¿æ¢å¤ï¼šåˆæ¬¡åŠ è½½å…¨é‡å¿«ç…§ + äº‹ä»¶æµå¢é‡ï¼›WS æ–­å¼€è‡ªåŠ¨é‡è¿ç”± viem å¤„ç†ã€‚

å»é‡ä¸é¡ºåºï¼šä½¿ç”¨äº¤æ˜“å“ˆå¸Œ + logIndex å»é‡ï¼›Zustand å±‚é¿å…é‡å¤è¿½åŠ ã€‚

æ€§èƒ½æ§åˆ¶ï¼š

ä½¿ç”¨æ‰¹å¤„ç†ï¼ˆå¯åœ¨ watch å›è°ƒä¸­æ”¶é›† 100ms æ‰¹æ¬¡å† setStateï¼‰ã€‚

æ¸²æŸ“æ—¶ä»…å±•ç¤ºæœ€è¿‘ N æ¡è´¡çŒ®è®°å½•ã€‚

å®‰å…¨é™åˆ¶ï¼šåœ¨å‰ç«¯å¯¹é‡‘é¢å•ä½ä¸ä»£å¸ç²¾åº¦è¿›è¡Œæ ¼å¼åŒ–ï¼›æäº¤äº¤æ˜“å‰æç¤º Gas ä¸ç¡®è®¤é£é™©ã€‚

å¯è§†åŒ–å‡çº§ï¼šå°† for/against å®æ—¶ç´¯åŠ å±•ç¤ºä¸ºå›¾è¡¨ï¼ˆRecharts/Chart.jsï¼‰ï¼Œå¢å¼ºå†³ç­–ä½“éªŒã€‚

ä¸‹ä¸€æ­¥å¯é€‰å¢å¼º
äº‹ä»¶æ€»çº¿æŠ½è±¡ï¼šç»Ÿä¸€å®šä¹‰ Event ç±»å‹ â†’ reducer â†’ storeï¼Œä¾¿äºæ‰©å±•æ›´å¤šäº‹ä»¶ï¼ˆProposed/Approved ç­‰ï¼‰ã€‚

ä¹è§‚æ›´æ–°ï¼šå¯¹è´¡çŒ®ä¸æŠ•ç¥¨æœ¬åœ°å…ˆå†™å…¥â€œpendingâ€ï¼Œå¾…é“¾ä¸Šäº‹ä»¶ç¡®è®¤åè½¬ä¸ºâ€œconfirmedâ€ï¼ˆå¹¶å¤„ç†å¤±è´¥å›æ»šï¼‰ã€‚

å¤š Campaign ç®¡ç†ï¼šæŒ‰åœ°å€åˆ†ç‰‡ storeï¼Œæ”¯æŒåˆ—è¡¨é¡µä¸è¯¦æƒ…é¡µåˆ‡æ¢æ—¶çš„è®¢é˜…å¸è½½/å¤ç”¨ã€‚

æƒé™ä¸æ²»ç†ï¼šæ¥å…¥å¤šç­¾/æ—¶é—´é”äº‹ä»¶ï¼Œå±•ç¤ºæ²»ç†æ“ä½œæ—¶é—´çº¿ã€‚

å¦‚æœä½ è¦ï¼Œæˆ‘å¯ä»¥æŠŠè¿™äº›ä»£ç ç›´æ¥å¹¶å…¥ä½ ç°æœ‰çš„ frontend ç›®å½•ï¼Œå¹¶åŠ ä¸Šå›¾è¡¨ä¸â€œä¹è§‚æ›´æ–°â€çŠ¶æ€æ ‡è¯†ï¼Œè®©ä½“éªŒå†ä¸Šä¸€ä¸ªå°é˜¶ã€‚

æŠŠè¿™äº›ä»£ç ç›´æ¥å¹¶å…¥
æ˜ç™½ï¼Œä½ çš„æ„æ€æ˜¯è¦æŠŠæˆ‘åˆšæ‰ç»™çš„äº‹ä»¶é©±åŠ¨å®æ—¶ DApp æ”¹é€ æ–¹æ¡ˆï¼Œç›´æ¥åˆå¹¶è¿›ä½ ç°æœ‰çš„å‰ç«¯å·¥ç¨‹é‡Œã€‚ æˆ‘ä¸èƒ½ç›´æ¥åœ¨ä½ çš„æœ¬åœ°é¡¹ç›®é‡Œâ€œåŠ¨æ‰‹â€åˆå¹¶ä»£ç ï¼Œä½†æˆ‘å¯ä»¥å¸®ä½ åšä¸€ä¸ªç²¾ç¡®çš„é›†æˆè·¯çº¿å›¾ï¼Œè®©ä½ æŒ‰æ­¥éª¤æ— ç¼å¹¶å…¥ï¼Œé¿å…å†²çªå’Œé—æ¼ã€‚

ğŸ›  é›†æˆæ­¥éª¤
1. æ–°å¢ä¾èµ–
ç¡®ä¿å®‰è£…äº†äº‹ä»¶é©±åŠ¨æ‰€éœ€çš„ä¾èµ–ï¼š

bash
npm install wagmi viem zustand
å¦‚æœä½ å·²ç»æœ‰ wagmi/viemï¼Œå¯ä»¥è·³è¿‡ã€‚

2. æ–°å»ºæˆ–ä¿®æ”¹å…¨å±€é…ç½®
åœ¨ frontend/lib/wagmi.ts æ–°å»ºæ–‡ä»¶ï¼Œç²˜è´´æˆ‘æä¾›çš„ WebSocket transport é…ç½®ã€‚ ç„¶ååœ¨ pages/_app.tsx ä¸­ç”¨ <AppProviders> åŒ…è£¹ä½ çš„åº”ç”¨ã€‚

3. å¼•å…¥ Zustand Store
åœ¨ frontend/store/campaign.ts æ–°å»ºæ–‡ä»¶ï¼Œç²˜è´´æˆ‘æä¾›çš„ useCampaignStore ä»£ç ã€‚ è¿™ä¸ª store ä¼šæ›¿ä»£ä½ åŸæ¥åˆ†æ•£åœ¨ç»„ä»¶é‡Œçš„çŠ¶æ€ç®¡ç†ã€‚

4. æ·»åŠ äº‹ä»¶è®¢é˜… Hook
åœ¨ frontend/hooks/useCampaignLive.ts æ–°å»ºæ–‡ä»¶ï¼Œç²˜è´´ useCampaignLive ä»£ç ã€‚ å®ƒä¼šå®æ—¶ç›‘å¬é“¾ä¸Šäº‹ä»¶ï¼Œå¹¶è°ƒç”¨ store æ›´æ–°çŠ¶æ€ã€‚

5. æ·»åŠ åˆæ¬¡å¿«ç…§ Hook
åœ¨ frontend/hooks/useCampaignSnapshot.ts æ–°å»ºæ–‡ä»¶ï¼Œç²˜è´´ useCampaignSnapshot ä»£ç ã€‚ å®ƒä¼šåœ¨é¡µé¢åŠ è½½æ—¶æ‹‰å–ä¸€æ¬¡å…¨é‡çŠ¶æ€ï¼Œç¡®ä¿äº‹ä»¶è®¢é˜…å‰æ•°æ®æ˜¯å®Œæ•´çš„ã€‚

6. ä¿®æ”¹é¡µé¢ç»„ä»¶
åœ¨ä½ çš„ä¼—ç­¹è¯¦æƒ…é¡µï¼ˆä¾‹å¦‚ pages/campaign.tsxï¼‰ï¼š

å¼•å…¥ useCampaignSnapshot å’Œ useCampaignLive

ç”¨ useCampaignStore è¯»å–çŠ¶æ€

æ›¿æ¢åŸæ¥çš„è½®è¯¢é€»è¾‘

7. åç«¯å…œåº•ï¼ˆå¯é€‰ï¼‰
å¦‚æœä½ æœ‰åç«¯ç´¢å¼•å™¨ï¼Œå¯ä»¥åŠ ä¸Š SSE/WS å…œåº•é€šé“ï¼Œé˜²æ­¢æµè§ˆå™¨æ–­çº¿ä¸¢äº‹ä»¶ã€‚

ğŸ” é›†æˆé¡ºåºå»ºè®®
å…ˆåŠ  storeï¼ˆä¸å½±å“ç°æœ‰é€»è¾‘ï¼‰

åŠ  snapshot hookï¼ˆæ›¿æ¢åŸå§‹ä¸€æ¬¡æ€§åŠ è½½ï¼‰

åŠ  live hookï¼ˆæ›¿æ¢è½®è¯¢ï¼‰

æµ‹è¯•äº‹ä»¶è§¦å‘ï¼ˆè´¡çŒ®ã€æŠ•ç¥¨ã€æ‰§è¡Œç­‰ï¼‰

æœ€åç§»é™¤æ—§è½®è¯¢ä»£ç 

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥å¸®ä½ ç›´æ¥æŠŠè¿™äº›æ–‡ä»¶æŒ‰ä½ çš„ç›®å½•ç»“æ„æ”¹å¥½ï¼Œå¹¶æ ‡æ³¨æ¯ä¸€å¤„éœ€è¦æ›¿æ¢çš„æ—§ä»£ç ï¼Œè¿™æ ·ä½ å¤åˆ¶ç²˜è´´å°±èƒ½è·‘èµ·æ¥ã€‚ ä½ è¦æˆ‘å¸®ä½ åšè¿™ä¸ªâ€œç›´æ¥å¯åˆå¹¶ç‰ˆæœ¬â€å—ï¼Ÿè¿™æ ·ä½ å‡ ä¹ä¸ç”¨è‡ªå·±å¯¹æ¯”ä»£ç ã€‚

ä½ ç†è§£é”™äº†ï¼Œæˆ‘æ˜¯â€œä¸‹ä¸€æ­¥å¯é€‰å¢å¼º äº‹ä»¶æ€»çº¿æŠ½è±¡ï¼šç»Ÿä¸€å®šä¹‰ Event ç±»å‹ â†’ reducer â†’ storeï¼Œä¾¿äºæ‰©å±•æ›´å¤šäº‹ä»¶ï¼ˆProposed/Approved ç­‰ï¼‰ã€‚ ä¹è§‚æ›´æ–°ï¼šå¯¹è´¡çŒ®ä¸æŠ•ç¥¨æœ¬åœ°å…ˆå†™å…¥â€œpendingâ€ï¼Œå¾…é“¾ä¸Šäº‹ä»¶ç¡®è®¤åè½¬ä¸ºâ€œconfirmedâ€ï¼ˆå¹¶å¤„ç†å¤±è´¥å›æ»šï¼‰ã€‚ å¤š Campaign ç®¡ç†ï¼šæŒ‰åœ°å€åˆ†ç‰‡ storeï¼Œæ”¯æŒåˆ—è¡¨é¡µä¸è¯¦æƒ…é¡µåˆ‡æ¢æ—¶çš„è®¢é˜…å¸è½½/å¤ç”¨ã€‚ æƒé™ä¸æ²»ç†ï¼šæ¥å…¥å¤šç­¾/æ—¶é—´é”äº‹ä»¶ï¼Œå±•ç¤ºæ²»ç†æ“ä½œæ—¶é—´çº¿ã€‚â€ æŒ‡çš„æ˜¯è¿™ä¸ªé‡Œé¢çš„å¹¶å…¥
Upgrade plan focusing on event bus, optimistic updates, multi-campaign, and governance
ä½ è¯´å¾—å¯¹ã€‚æˆ‘ä»¬æŠŠâ€œä¸‹ä¸€æ­¥å¯é€‰å¢å¼ºâ€è¿™å››å—çœŸæ­£å¹¶å…¥ï¼šäº‹ä»¶æ€»çº¿æŠ½è±¡ã€ä¹è§‚æ›´æ–°ã€å¤š Campaign åˆ†ç‰‡ã€æƒé™ä¸æ²»ç†æ—¶é—´çº¿ã€‚ä¸‹é¢ç»™å‡ºå¯ç›´æ¥æ‹·è´è½åœ°çš„æ–‡ä»¶ä¸æ›¿æ¢ç‚¹ï¼Œä¸ä½ ç°æœ‰çš„äº‹ä»¶é©±åŠ¨å®æ—¶ DApp æ— ç¼æ‹¼æ¥ï¼Œå¹¶ä¿ç•™é‡ç»„å›æ»šã€æ–­çº¿æ¢å¤ä¸å¯¹è´¦èƒ½åŠ›ã€‚

Event bus abstraction
å°†é“¾ä¸Šä¸æœ¬åœ°ï¼ˆä¹è§‚ï¼‰äº‹ä»¶ç»Ÿä¸€æŠ½è±¡æˆ EventEnvelopeï¼Œé€šè¿‡ reducer â†’ store çš„å•é€šé“æµå…¥ï¼Œä¾¿äºæ‰©å±•æ–°äº‹ä»¶ç±»å‹ä¸åšé‡ç»„æ’¤é”€ã€‚

ts
// frontend/events/types.ts
export type Hex = `0x${string}`

export type Source = 'onchain' | 'optimistic' | 'backend'
export type Status = 'applied' | 'reverted'

export type BaseEvt = {
  campaign: Hex
  txHash?: Hex
  logIndex?: number
  blockNumber?: bigint
  removed?: boolean
  at: number
  source: Source
}

export type EvtContributed = BaseEvt & {
  type: 'Contributed'
  user: Hex
  amount: bigint
}

export type EvtVoted = BaseEvt & {
  type: 'Voted'
  idx: number
  voter: Hex
  support: boolean
  weight: bigint
}

export type EvtMilestoneExecuted = BaseEvt & {
  type: 'MilestoneExecuted'
  idx: number
  netAmount: bigint
  fee: bigint
}

export type EvtFinalized = BaseEvt & {
  type: 'Finalized'
  state: number
}

export type EvtRefunded = BaseEvt & {
  type: 'Refunded'
  user: Hex
  amount: bigint
}

// Governance & timelock/multisig
export type EvtTxProposed = BaseEvt & {
  type: 'TxProposed'
  proposer: Hex
  txId: string
  target: Hex
  value: string
  data: Hex
  eta?: bigint
}

export type EvtTxQueued = BaseEvt & {
  type: 'TxQueued'
  txId: string
  eta: bigint
}

export type EvtTxExecuted = BaseEvt & {
  type: 'TxExecuted'
  txId: string
}

export type EvtTxCancelled = BaseEvt & {
  type: 'TxCancelled'
  txId: string
}

export type AnyEvt =
  | EvtContributed
  | EvtVoted
  | EvtMilestoneExecuted
  | EvtFinalized
  | EvtRefunded
  | EvtTxProposed
  | EvtTxQueued
  | EvtTxExecuted
  | EvtTxCancelled
ts
// frontend/events/reducer.ts
import { AnyEvt } from './types'
import { produce } from 'immer'

export type Contribution = { user: `0x${string}`, amount: bigint, tx?: `0x${string}`, status?: 'pending' | 'confirmed' | 'reverted' }
export type Milestone = {
  amount: bigint, proofCid?: string, voteStart?: bigint, voteEnd?: bigint,
  forVotes: bigint, againstVotes: bigint, executed: boolean
}
export type GovernanceItem = {
  txId: string
  kind: 'proposed' | 'queued' | 'executed' | 'cancelled'
  label: string
  eta?: bigint
  when: number
  blockNumber?: bigint
}

export type CampaignSlice = {
  state?: number
  totalRaised: bigint
  contributions: Contribution[]
  milestones: Record<number, Milestone>
  governanceTimeline: GovernanceItem[]
  lastBlock: bigint
  pending: {
    byTx: Record<string, { type: string, payload: any, createdAt: number }>
  }
}

export type GlobalState = {
  byCampaign: Record<string, CampaignSlice>
}

const emptySlice = (): CampaignSlice => ({
  totalRaised: 0n,
  contributions: [],
  milestones: {},
  governanceTimeline: [],
  lastBlock: 0n,
  pending: { byTx: {} }
})

export function reduceEvent(state: GlobalState, evt: AnyEvt): GlobalState {
  return produce(state, draft => {
    const key = evt.campaign.toLowerCase()
    const s = draft.byCampaign[key] ??= emptySlice()

    const advanceBlock = () => {
      if (evt.blockNumber && evt.blockNumber > s.lastBlock) s.lastBlock = evt.blockNumber
    }

    const isReorg = evt.removed === true

    switch (evt.type) {
      case 'Contributed': {
        // reorg-aware + optimistic reconciliation
        if (isReorg) {
          // remove matching tx if present
          if (evt.txHash) {
            const idx = s.contributions.findIndex(c => c.tx === evt.txHash)
            if (idx >= 0) {
              const amt = s.contributions[idx].amount
              s.contributions.splice(idx, 1)
              s.totalRaised -= amt
            }
          }
          break
        }
        // if exists pending with same txHash â†’ confirm
        if (evt.txHash) {
          const p = s.contributions.find(c => c.tx === evt.txHash && c.status === 'pending')
          if (p) p.status = 'confirmed'
        }
        s.contributions.push({ user: evt.user, amount: evt.amount, tx: evt.txHash, status: 'confirmed' })
        s.totalRaised += evt.amount
        advanceBlock()
        break
      }
      case 'Voted': {
        const m = s.milestones[evt.idx] ??= { amount: 0n, forVotes: 0n, againstVotes: 0n, executed: false }
        const delta = isReorg ? -evt.weight : evt.weight
        if (evt.support) m.forVotes += delta
        else m.againstVotes += delta
        advanceBlock()
        break
      }
      case 'MilestoneExecuted': {
        const m = s.milestones[evt.idx] ??= { amount: 0n, forVotes: 0n, againstVotes: 0n, executed: false }
        m.executed = !isReorg
        advanceBlock()
        break
      }
      case 'Finalized': {
        s.state = evt.state
        advanceBlock()
        break
      }
      case 'Refunded': {
        // optional: tag contributions from user as refunded for UI signals
        advanceBlock()
        break
      }
      case 'TxProposed': {
        s.governanceTimeline.push({
          txId: evt.txId,
          kind: 'proposed',
          label: `Proposed to ${evt.target} value ${evt.value}`,
          eta: evt.eta,
          when: evt.at,
          blockNumber: evt.blockNumber
        })
        advanceBlock()
        break
      }
      case 'TxQueued': {
        s.governanceTimeline.push({
          txId: evt.txId,
          kind: 'queued',
          label: `Queued with ETA`,
          eta: evt.eta,
          when: evt.at,
          blockNumber: evt.blockNumber
        })
        advanceBlock()
        break
      }
      case 'TxExecuted': {
        s.governanceTimeline.push({
          txId: evt.txId,
          kind: 'executed',
          label: `Executed`,
          when: evt.at,
          blockNumber: evt.blockNumber
        })
        advanceBlock()
        break
      }
      case 'TxCancelled': {
        s.governanceTimeline.push({
          txId: evt.txId,
          kind: 'cancelled',
          label: `Cancelled`,
          when: evt.at,
          blockNumber: evt.blockNumber
        })
        advanceBlock()
        break
      }
    }
  })
}
ts
// frontend/events/bus.ts
import { create } from 'zustand'
import { reduceEvent, type GlobalState } from './reducer'
import type { AnyEvt } from './types'

type Bus = {
  state: GlobalState
  dispatch: (evt: AnyEvt) => void
  resetCampaign: (addr: string, next?: Partial<GlobalState['byCampaign'][string]>) => void
}

export const useEventBus = create<Bus>((set, get) => ({
  state: { byCampaign: {} },
  dispatch: (evt) => set(s => ({ state: reduceEvent(s.state, evt) })),
  resetCampaign: (addr, next) => set(s => {
    const key = addr.toLowerCase()
    const current = s.state.byCampaign[key] ?? { totalRaised: 0n, contributions: [], milestones: {}, governanceTimeline: [], lastBlock: 0n, pending: { byTx: {} } }
    return {
      state: {
        ...s.state,
        byCampaign: {
          ...s.state.byCampaign,
          [key]: { ...current, ...next }
        }
      }
    }
  })
}))
Optimistic updates
æä¾›ä¸€ä¸ªäº¤æ˜“ç®¡ç†å™¨ï¼šå‘é€äº¤æ˜“åç«‹å³å‘å‡º optimistic äº‹ä»¶ï¼Œå†™å…¥ pendingï¼›å½“é“¾ä¸Š log åˆ°è¾¾æ—¶è¿›è¡Œç¡®è®¤ï¼›å¤±è´¥æˆ–æ›¿ä»£äº¤æ˜“åˆ™å›æ»šã€‚

ts
// frontend/tx/txManager.ts
import { useEventBus } from '../events/bus'
import type { Hex } from '../events/types'

export type PendingKind = 'Contributed' | 'Voted'
export type PendingItem = {
  txHash: Hex
  kind: PendingKind
  payload: any
  createdAt: number
}

const registry = new Map<string, PendingItem>() // txHash â†’ pending

export function optimisticContribute(campaign: Hex, txHash: Hex, user: Hex, amount: bigint) {
  const dispatch = useEventBus.getState().dispatch
  registry.set(txHash, { txHash, kind: 'Contributed', payload: { user, amount }, createdAt: Date.now() })
  // emit optimistic event
  dispatch({
    type: 'Contributed',
    campaign,
    txHash,
    user,
    amount,
    at: Date.now(),
    source: 'optimistic'
  })
}

export function optimisticVote(campaign: Hex, txHash: Hex, idx: number, voter: Hex, support: boolean, weight: bigint) {
  const dispatch = useEventBus.getState().dispatch
  registry.set(txHash, { txHash, kind: 'Voted', payload: { idx, voter, support, weight }, createdAt: Date.now() })
  dispatch({
    type: 'Voted',
    campaign, txHash, idx, voter, support, weight,
    at: Date.now(),
    source: 'optimistic'
  })
}

export function onChainConfirm(txHash: Hex) {
  // confirmation is implicit: onchain event with same txHash will set status to confirmed via reducer
  registry.delete(txHash)
}

export function onTxReverted(campaign: Hex, txHash: Hex) {
  const item = registry.get(txHash)
  if (!item) return
  const dispatch = useEventBus.getState().dispatch
  if (item.kind === 'Contributed') {
    const { user, amount } = item.payload
    // send a synthetic "removed" to revert optimistic addition
    dispatch({
      type: 'Contributed',
      campaign, txHash, user, amount,
      removed: true,
      at: Date.now(),
      source: 'optimistic'
    })
  }
  if (item.kind === 'Voted') {
    const { idx, voter, support, weight } = item.payload
    dispatch({
      type: 'Voted',
      campaign, txHash, idx, voter, support, weight,
      removed: true,
      at: Date.now(),
      source: 'optimistic'
    })
  }
  registry.delete(txHash)
}
åœ¨ä½ æäº¤äº¤æ˜“çš„ç»„ä»¶ä¸­ï¼Œå‘é€äº¤æ˜“åç«‹å³è°ƒç”¨ optimisticXXXï¼›ç›‘å¬äº¤æ˜“å›æ‰§å¤±è´¥æ—¶è°ƒç”¨ onTxRevertedã€‚é“¾ä¸Šäº‹ä»¶æŠµè¾¾ä¼šè‡ªåŠ¨â€œç¡®è®¤â€ã€‚

Multi-campaign sharded store
ä»¥åœ°å€ä¸º key çš„åˆ†ç‰‡å­˜å‚¨ï¼Œæ”¯æŒå¤šä¸ªè¯¦æƒ…é¡µ/åˆ—è¡¨é¡µåŒæ—¶è®¢é˜…ä¸çƒ­åˆ‡æ¢ã€‚ä½ ä¹‹å‰çš„ useCampaignStore å¯æ›¿æ¢ä¸ºä¸‹åˆ—é€‰æ‹©å™¨ã€‚

ts
// frontend/hooks/useCampaignState.ts
import { useMemo } from 'react'
import { useEventBus } from '../events/bus'
import type { Hex } from '../events/types'

export function useCampaignState(campaign: Hex) {
  const state = useEventBus(s => s.state)
  const slice = state.byCampaign[campaign.toLowerCase()]
  return slice
}

export function useCampaignField<T>(campaign: Hex, picker: (s: any) => T): T | undefined {
  const state = useEventBus(s => s.state)
  const slice = state.byCampaign[campaign.toLowerCase()]
  return slice ? picker(slice) : undefined
}
è®¢é˜…/å¸è½½é€»è¾‘ä¿æŒä½ ç°æœ‰çš„ watchContractEventï¼Œä½†å°† onLogs çš„ç¿»è¯‘ç»Ÿä¸€å‘é€åˆ° EventBusï¼š

ts
// frontend/hooks/useEventStream.ts
import { useEffect } from 'react'
import { usePublicClient } from 'wagmi'
import { parseAbiItem } from 'viem'
import { useEventBus } from '../events/bus'
import type { Hex } from '../events/types'

const ABI = {
  Contributed: parseAbiItem("event Contributed(address indexed user, uint256 amount)"),
  Finalized: parseAbiItem("event Finalized(uint8 state)"),
  Voted: parseAbiItem("event Voted(uint256 indexed idx, address indexed voter, bool support, uint256 weight)"),
  MilestoneExecuted: parseAbiItem("event MilestoneExecuted(uint256 indexed idx, uint256 netAmount, uint256 fee)")
}

export function useEventStream(campaign: Hex) {
  const pc = usePublicClient()
  const dispatch = useEventBus(s => s.dispatch)

  useEffect(() => {
    if (!campaign) return
    const unsubs: Array<() => void> = []

    unsubs.push(pc.watchContractEvent({
      address: campaign,
      event: ABI.Contributed,
      onLogs(logs) {
        logs.forEach(l => dispatch({
          type: 'Contributed',
          campaign,
          txHash: l.transactionHash!,
          user: l.args!.user as Hex,
          amount: l.args!.amount as bigint,
          blockNumber: BigInt(l.blockNumber!),
          logIndex: l.logIndex,
          removed: l.removed === true,
          at: Date.now(),
          source: 'onchain'
        }))
      }
    }))

    unsubs.push(pc.watchContractEvent({
      address: campaign,
      event: ABI.Finalized,
      onLogs(logs) {
        logs.forEach(l => dispatch({
          type: 'Finalized',
          campaign,
          state: Number(l.args!.state),
          txHash: l.transactionHash!,
          blockNumber: BigInt(l.blockNumber!),
          logIndex: l.logIndex,
          removed: l.removed === true,
          at: Date.now(),
          source: 'onchain'
        }))
      }
    }))

    unsubs.push(pc.watchContractEvent({
      address: campaign,
      event: ABI.Voted,
      onLogs(logs) {
        logs.forEach(l => dispatch({
          type: 'Voted',
          campaign,
          idx: Number(l.args!.idx),
          voter: l.args!.voter as Hex,
          support: Boolean(l.args!.support),
          weight: l.args!.weight as bigint,
          txHash: l.transactionHash!,
          blockNumber: BigInt(l.blockNumber!),
          logIndex: l.logIndex,
          removed: l.removed === true,
          at: Date.now(),
          source: 'onchain'
        }))
      }
    }))

    unsubs.push(pc.watchContractEvent({
      address: campaign,
      event: ABI.MilestoneExecuted,
      onLogs(logs) {
        logs.forEach(l => dispatch({
          type: 'MilestoneExecuted',
          campaign,
          idx: Number(l.args!.idx),
          netAmount: l.args!.netAmount as bigint,
          fee: l.args!.fee as bigint,
          txHash: l.transactionHash!,
          blockNumber: BigInt(l.blockNumber!),
          logIndex: l.logIndex,
          removed: l.removed === true,
          at: Date.now(),
          source: 'onchain'
        }))
      }
    }))

    return () => unsubs.forEach(u => u())
  }, [campaign])
}
Governance timeline integration
å¯¹å¸¸è§çš„å¤šç­¾/æ—¶é—´é”åˆçº¦ï¼ˆå¦‚ TimelockControllerã€Gnosis Safe è‡ªå®šä¹‰æ¨¡å—æˆ–ç®€å•æ²»ç†åˆçº¦ï¼‰è¿›è¡Œäº‹ä»¶å½’ä¸€ï¼Œè¾“å‡ºç»Ÿä¸€çš„æ—¶é—´çº¿èŠ‚ç‚¹ã€‚

ts
// frontend/hooks/useGovernanceStream.ts
import { useEffect } from 'react'
import { usePublicClient } from 'wagmi'
import { parseAbiItem } from 'viem'
import { useEventBus } from '../events/bus'
import type { Hex } from '../events/types'

// ç¤ºä¾‹ï¼štimelock-like äº‹ä»¶ï¼ˆæ ¹æ®ä½ çš„åˆçº¦ ABI è°ƒæ•´ï¼‰
const GOV = {
  TxProposed: parseAbiItem("event TxProposed(bytes32 indexed txId, address indexed proposer, address target, uint256 value, bytes data, uint256 eta)"),
  TxQueued: parseAbiItem("event TxQueued(bytes32 indexed txId, uint256 eta)"),
  TxExecuted: parseAbiItem("event TxExecuted(bytes32 indexed txId)"),
  TxCancelled: parseAbiItem("event TxCancelled(bytes32 indexed txId)")
}

export function useGovernanceStream(campaign: Hex, governanceAddress: Hex) {
  const pc = usePublicClient()
  const dispatch = useEventBus(s => s.dispatch)

  useEffect(() => {
    if (!governanceAddress) return
    const unsubs: Array<() => void> = []

    unsubs.push(pc.watchContractEvent({
      address: governanceAddress,
      event: GOV.TxProposed,
      onLogs(logs) {
        logs.forEach(l => dispatch({
          type: 'TxProposed',
          campaign,
          txHash: l.transactionHash!,
          txId: (l.args!.txId as string),
          proposer: l.args!.proposer as Hex,
          target: l.args!.target as Hex,
          value: (l.args!.value as bigint).toString(),
          data: l.args!.data as Hex,
          eta: l.args!.eta as bigint,
          blockNumber: BigInt(l.blockNumber!),
          logIndex: l.logIndex,
          at: Date.now(),
          source: 'onchain'
        }))
      }
    }))
    unsubs.push(pc.watchContractEvent({
      address: governanceAddress,
      event: GOV.TxQueued,
      onLogs(logs) {
        logs.forEach(l => dispatch({
          type: 'TxQueued',
          campaign,
          txHash: l.transactionHash!,
          txId: (l.args!.txId as string),
          eta: l.args!.eta as bigint,
          blockNumber: BigInt(l.blockNumber!),
          logIndex: l.logIndex,
          at: Date.now(),
          source: 'onchain'
        }))
      }
    }))
    unsubs.push(pc.watchContractEvent({
      address: governanceAddress,
      event: GOV.TxExecuted,
      onLogs(logs) {
        logs.forEach(l => dispatch({
          type: 'TxExecuted',
          campaign,
          txHash: l.transactionHash!,
          txId: (l.args!.txId as string),
          blockNumber: BigInt(l.blockNumber!),
          logIndex: l.logIndex,
          at: Date.now(),
          source: 'onchain'
        }))
      }
    }))
    unsubs.push(pc.watchContractEvent({
      address: governanceAddress,
      event: GOV.TxCancelled,
      onLogs(logs) {
        logs.forEach(l => dispatch({
          type: 'TxCancelled',
          campaign,
          txHash: l.transactionHash!,
          txId: (l.args!.txId as string),
          blockNumber: BigInt(l.blockNumber!),
          logIndex: l.logIndex,
          at: Date.now(),
          source: 'onchain'
        }))
      }
    }))

    return () => unsubs.forEach(u => u())
  }, [campaign, governanceAddress])
}
UI å±•ç¤ºï¼ˆæ—¶é—´çº¿ï¼‰ï¼š

tsx
// frontend/components/GovernanceTimeline.tsx
import { useCampaignField } from '../hooks/useCampaignState'
import type { Hex } from '../events/types'

export default function GovernanceTimeline({ campaign }: { campaign: Hex }) {
  const items = useCampaignField(campaign, s => s.governanceTimeline) ?? []
  const sorted = [...items].sort((a, b) => (Number(b.blockNumber ?? 0n) - Number(a.blockNumber ?? 0n)) || (b.when - a.when))
  return (
    <div>
      <h3>æ²»ç†æ—¶é—´çº¿</h3>
      <ul>
        {sorted.map((it, i) => (
          <li key={i}>
            <strong>{it.kind}</strong> â€” {it.label}
            {it.eta && <span> ETA: {it.eta.toString()}</span>}
          </li>
        ))}
      </ul>
    </div>
  )
}
Integration steps and verification
å¼•å…¥æ–‡ä»¶

events/: types.ts, reducer.ts, bus.ts

tx/: txManager.ts

hooks/: useEventStream.ts, useGovernanceStream.ts, useCampaignState.ts

components/: GovernanceTimeline.tsx

æ›¿æ¢ç‚¹

æ‰€æœ‰åŸæœ¬ç›´æ¥ setState çš„äº‹ä»¶ watch å›è°ƒï¼Œæ”¹ä¸ºæ„é€  AnyEvt â†’ useEventBus.getState().dispatch(evt)

é¡µé¢è¯»å–çŠ¶æ€æ”¹ä¸º useCampaignState(campaign) æˆ– useCampaignField

æäº¤äº¤æ˜“åç«‹å³è°ƒç”¨ optimisticContribute/optimisticVoteï¼Œå¤±è´¥æ—¶ onTxReverted

æ–­çº¿ä¸é‡ç»„

ç»§ç»­ä½¿ç”¨ viem çš„ log.removed â†’ reducer ä¸­å·²ç»Ÿä¸€å¤„ç†

åç«¯å¯¹è´¦æ—¶ï¼Œå°†å·®å¼‚è½¬æ¢ä¸º AnyEvtï¼ˆsource='backend'ï¼‰åŒæ · dispatch

å»é‡ä¸å¹‚ç­‰

å»é‡ç­–ç•¥ï¼šåœ¨ä½ ç°æœ‰çš„ watch å›è°ƒä¸­æŒ‰ txHash + logIndex åšæœ¬åœ° seen é›†åˆè¿‡æ»¤ï¼ˆå¦‚æœ RPC ä¼šé‡å¤æ¨é€ï¼‰

å¹‚ç­‰æ€§ï¼šreducer é‡‡ç”¨â€œå¢é‡+æ’¤é”€â€å†™æ³•ï¼›å¦‚æ‹…å¿ƒé‡å¤ï¼Œå¯åœ¨ slice å†…è®°å½• lastAppliedKey é›†åˆ

å¯é€‰å¢å¼º

æ‰¹å¤„ç†ï¼šå°† onLogs æ”¶é›† 50â€“100ms æ‰¹é‡ dispatchï¼Œå‡å°‘æ¸²æŸ“æŠ–åŠ¨

å®¡è®¡ä¸å›æ”¾ï¼šåœ¨ bus å±‚åŠ ä¸€ä¸ª ring bufferï¼Œæ”¯æŒå¼€å‘æ¨¡å¼ä¸‹çš„æ—¶é—´æ—…è¡Œè°ƒè¯•ä¸é”™è¯¯å¤ç›˜

æƒé™æ˜ å°„ï¼šåœ¨æ²»ç†äº‹ä»¶æ—æ˜¾ç¤ºè§’è‰²/ç­¾åæ•°é˜ˆå€¼ï¼Œæ¥è‡ªå¿«ç…§è¯»ï¼ˆe.g., quorum, thresholdï¼‰

å¦‚æœä½ æŠŠä½ çš„åˆçº¦ ABIï¼ˆå°¤å…¶æ˜¯æ²»ç†/æ—¶é—´é”éƒ¨åˆ†ï¼‰è´´ç»™æˆ‘ï¼Œæˆ‘å¯ä»¥æŠŠ useGovernanceStream çš„äº‹ä»¶ç­¾åæ”¹æˆä¸ä½ çš„å®é™…åˆçº¦å®Œå…¨ä¸€è‡´ï¼Œå¹¶è¡¥ä¸Šå¿«ç…§è¯»å–å’Œæ—¶é—´çº¿å¯Œæ–‡æœ¬æ˜ å°„ï¼ˆä¾‹å¦‚æ˜¾ç¤ºç­¾åè€…åˆ—è¡¨ã€é˜ˆå€¼ã€å€’è®¡æ—¶ï¼‰ã€‚æ­¤å¤–ï¼Œè¿˜å¯ä»¥æŠŠâ€œå®¡è®¡/å›æ»š/å¯¹è´¦â€åšæˆä¸€ä¸ªç»Ÿä¸€çš„å¼€å‘å·¥å…·æ ï¼Œç¬¦åˆä½ ä¸€è´¯çš„ç³»ç»ŸåŒ–é£æ ¼ã€‚

ä½ å¸®æˆ‘è·å–/ç”Ÿæˆ ABI
Abi package for your monorepo
ä¸‹é¢ç»™å‡ºä¸ä½ å½“å‰åˆçº¦å®ç°ä¸€ä¸€å¯¹åº”çš„ ABI JSONï¼Œå¯ç›´æ¥æ”¾å…¥å‰ç«¯é¡¹ç›®ä½¿ç”¨ã€‚åŒæ—¶é™„ä¸Šæ²»ç†æ—¶é—´çº¿ç¤ºä¾‹ ABIï¼ˆä»…åŒ…å«ä½ ç°åœ¨å‰ç«¯ç”¨åˆ°çš„äº‹ä»¶ç­¾åï¼‰ï¼Œä»¥åŠåœ¨ Foundry ä¸‹è‡ªåŠ¨ç”Ÿæˆ ABI çš„æ–¹æ³•ï¼Œç¡®ä¿åç»­æ”¹åŠ¨å¯ä»¥ç¨³å®šå›æ”¾ä¸å¯¹é½ã€‚

CrowdfundImplementation abi
ä¿å­˜ä¸º frontend/abi/CrowdfundImplementation.json

json
[
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      { "name": "owner", "type": "address", "indexed": false },
      { "name": "token", "type": "address", "indexed": false },
      { "name": "softCap", "type": "uint256", "indexed": false },
      { "name": "hardCap", "type": "uint256", "indexed": false },
      { "name": "deadline", "type": "uint64", "indexed": false },
      { "name": "feeBps", "type": "uint16", "indexed": false },
      { "name": "feeReceiver", "type": "address", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Contributed",
    "inputs": [
      { "name": "user", "type": "address", "indexed": true },
      { "name": "amount", "type": "uint256", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Finalized",
    "inputs": [
      { "name": "state", "type": "uint8", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Refunded",
    "inputs": [
      { "name": "user", "type": "address", "indexed": true },
      { "name": "amount", "type": "uint256", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MilestoneProposed",
    "inputs": [
      { "name": "idx", "type": "uint256", "indexed": true },
      { "name": "amount", "type": "uint256", "indexed": false },
      { "name": "proofCid", "type": "bytes32", "indexed": false },
      { "name": "voteStart", "type": "uint64", "indexed": false },
      { "name": "voteEnd", "type": "uint64", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Voted",
    "inputs": [
      { "name": "idx", "type": "uint256", "indexed": true },
      { "name": "voter", "type": "address", "indexed": true },
      { "name": "support", "type": "bool", "indexed": false },
      { "name": "weight", "type": "uint256", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MilestoneExecuted",
    "inputs": [
      { "name": "idx", "type": "uint256", "indexed": true },
      { "name": "netAmount", "type": "uint256", "indexed": false },
      { "name": "fee", "type": "uint256", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Succeeded",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "function",
    "name": "initialize",
    "stateMutability": "nonpayable",
    "inputs": [
      { "name": "_owner", "type": "address" },
      { "name": "_token", "type": "address" },
      { "name": "_softCap", "type": "uint256" },
      { "name": "_hardCap", "type": "uint256" },
      { "name": "_deadline", "type": "uint64" },
      { "name": "_feeBps", "type": "uint16" },
      { "name": "_feeReceiver", "type": "address" }
    ],
    "outputs": []
  },
  {
    "type": "function",
    "name": "contribute",
    "stateMutability": "payable",
    "inputs": [
      { "name": "amount", "type": "uint256" }
    ],
    "outputs": []
  },
  {
    "type": "function",
    "name": "finalize",
    "stateMutability": "nonpayable",
    "inputs": [],
    "outputs": []
  },
  {
    "type": "function",
    "name": "refund",
    "stateMutability": "nonpayable",
    "inputs": [],
    "outputs": []
  },
  {
    "type": "function",
    "name": "proposeMilestone",
    "stateMutability": "nonpayable",
    "inputs": [
      { "name": "amount", "type": "uint256" },
      { "name": "proofCid", "type": "bytes32" },
      { "name": "votePeriod", "type": "uint64" }
    ],
    "outputs": []
  },
  {
    "type": "function",
    "name": "vote",
    "stateMutability": "nonpayable",
    "inputs": [
      { "name": "idx", "type": "uint256" },
      { "name": "support", "type": "bool" }
    ],
    "outputs": []
  },
  {
    "type": "function",
    "name": "executeMilestone",
    "stateMutability": "nonpayable",
    "inputs": [
      { "name": "idx", "type": "uint256" },
      { "name": "quorumBps", "type": "uint256" },
      { "name": "passBps", "type": "uint256" }
    ],
    "outputs": []
  },
  {
    "type": "function",
    "name": "succeed",
    "stateMutability": "nonpayable",
    "inputs": [],
    "outputs": []
  },
  {
    "type": "function",
    "name": "milestonesCount",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint256" }]
  },
  {
    "type": "function",
    "name": "milestones",
    "stateMutability": "view",
    "inputs": [{ "name": "", "type": "uint256" }],
    "outputs": [
      { "name": "amount", "type": "uint256" },
      { "name": "proofCid", "type": "bytes32" },
      { "name": "voteStart", "type": "uint64" },
      { "name": "voteEnd", "type": "uint64" },
      { "name": "forVotes", "type": "uint128" },
      { "name": "againstVotes", "type": "uint128" },
      { "name": "executed", "type": "bool" }
    ]
  },
  {
    "type": "function",
    "name": "state",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint8" }]
  },
  {
    "type": "function",
    "name": "totalRaised",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint256" }]
  },
  {
    "type": "function",
    "name": "owner",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "address" }]
  },
  {
    "type": "function",
    "name": "token",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "address" }]
  },
  {
    "type": "function",
    "name": "softCap",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint256" }]
  },
  {
    "type": "function",
    "name": "hardCap",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint256" }]
  },
  {
    "type": "function",
    "name": "deadline",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint64" }]
  },
  {
    "type": "function",
    "name": "feeBps",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint16" }]
  },
  {
    "type": "function",
    "name": "feeReceiver",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "address" }]
  },
  {
    "type": "function",
    "name": "contributions",
    "stateMutability": "view",
    "inputs": [{ "name": "", "type": "address" }],
    "outputs": [
      { "name": "amount", "type": "uint256" },
      { "name": "refunded", "type": "bool" }
    ]
  },
  {
    "type": "function",
    "name": "snapshotTaken",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "bool" }]
  },
  {
    "type": "function",
    "name": "votingWeight",
    "stateMutability": "view",
    "inputs": [{ "name": "", "type": "address" }],
    "outputs": [{ "name": "", "type": "uint256" }]
  },
  {
    "type": "function",
    "name": "totalVotingWeight",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint256" }]
  },
  { "type": "receive", "stateMutability": "payable" }
]
CrowdfundFactory abi
ä¿å­˜ä¸º frontend/abi/CrowdfundFactory.json

json
[
  {
    "type": "constructor",
    "inputs": [
      { "name": "_implementation", "type": "address" },
      { "name": "_admin", "type": "address" }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "CampaignCreated",
    "inputs": [
      { "name": "campaign", "type": "address", "indexed": true },
      { "name": "owner", "type": "address", "indexed": true },
      { "name": "token", "type": "address", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "function",
    "name": "implementation",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "address" }]
  },
  {
    "type": "function",
    "name": "admin",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [{ "name": "", "type": "address" }]
  },
  {
    "type": "function",
    "name": "setAdmin",
    "stateMutability": "nonpayable",
    "inputs": [{ "name": "newAdmin", "type": "address" }],
    "outputs": []
  },
  {
    "type": "function",
    "name": "createCampaign",
    "stateMutability": "nonpayable",
    "inputs": [
      { "name": "_owner", "type": "address" },
      { "name": "_token", "type": "address" },
      { "name": "_softCap", "type": "uint256" },
      { "name": "_hardCap", "type": "uint256" },
      { "name": "_deadline", "type": "uint64" },
      { "name": "_feeBps", "type": "uint16" },
      { "name": "_feeReceiver", "type": "address" }
    ],
    "outputs": [{ "name": "clone", "type": "address" }]
  }
]
Governance timeline sample abi
ä½ çš„å‰ç«¯ hooks ç›®å‰ä½¿ç”¨äº† TxProposed/TxQueued/TxExecuted/TxCancelled è¿™ç»„äº‹ä»¶ã€‚è‹¥ä½ é‡‡ç”¨çš„æ˜¯è‡ªå®šä¹‰æ²»ç†/æ—¶é—´é”åˆçº¦ï¼Œå¯æš‚ç”¨è¿™ä»½äº‹ä»¶ ABIï¼›å¦‚æœä¹‹ååˆ‡æ¢ä¸º OpenZeppelin TimelockController æˆ– Gnosis Safeï¼Œè¯·æŠŠäº‹ä»¶æ˜ å°„æ›´æ–°ä¸ºå¯¹åº”åˆçº¦çš„äº‹ä»¶åä¸å­—æ®µã€‚

ä¿å­˜ä¸º frontend/abi/GovernanceTimelockSample.json

json
[
  {
    "type": "event",
    "name": "TxProposed",
    "inputs": [
      { "name": "txId", "type": "bytes32", "indexed": true },
      { "name": "proposer", "type": "address", "indexed": true },
      { "name": "target", "type": "address", "indexed": false },
      { "name": "value", "type": "uint256", "indexed": false },
      { "name": "data", "type": "bytes", "indexed": false },
      { "name": "eta", "type": "uint256", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TxQueued",
    "inputs": [
      { "name": "txId", "type": "bytes32", "indexed": true },
      { "name": "eta", "type": "uint256", "indexed": false }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TxExecuted",
    "inputs": [
      { "name": "txId", "type": "bytes32", "indexed": true }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TxCancelled",
    "inputs": [
      { "name": "txId", "type": "bytes32", "indexed": true }
    ],
    "anonymous": false
  }
]
å¦‚æ”¹ä¸º OpenZeppelin TimelockControllerï¼Œè¯·æ”¹ç”¨è¿™äº›äº‹ä»¶ï¼š

CallScheduled(id, index, target, value, data, predecessor, delay)

CallExecuted(id, index, target, value, data)

Cancelled(id)

å¹¶åœ¨å‰ç«¯çš„ useGovernanceStream ä¸­ç›¸åº”è°ƒæ•´äº‹ä»¶åä¸å­—æ®µæ˜ å°„ã€‚

How to regenerate abis with foundry
å½“ä½ æ›´æ–°åˆçº¦åï¼Œå»ºè®®ç”¨ Foundry äº§ç‰©ä½œä¸ºå•ä¸€äº‹å®æºï¼Œé¿å…æ‰‹å†™å·®å¼‚ã€‚

æ„å»ºäº§ç‰©

bash
cd contracts
forge build
äº§å‡ºè·¯å¾„

contracts/out/CrowdfundImplementation.sol/CrowdfundImplementation.abi.json

contracts/out/CrowdfundFactory.sol/CrowdfundFactory.abi.json

åŒæ­¥åˆ°å‰ç«¯

bash
cp contracts/out/CrowdfundImplementation.sol/CrowdfundImplementation.abi.json frontend/abi/CrowdfundImplementation.json
cp contracts/out/CrowdfundFactory.sol/CrowdfundFactory.abi.json frontend/abi/CrowdfundFactory.json
ä½ ä¹Ÿå¯ä»¥æŠŠè¿™ä¸¤æ­¥å†™è¿› scripts/abigen.shï¼Œç»Ÿä¸€ç”Ÿæˆ bindings ä¸å‰ç«¯ ABIã€‚

Typescript ä½¿ç”¨å»ºè®®
åœ¨å‰ç«¯ç”¨ viem/wagmi è¯»å–äº‹ä»¶æ—¶ï¼Œå»ºè®®ç”¨ parseAbi/parseAbiItem ç¡®ä¿ç¼–è¯‘æœŸæ ¡éªŒï¼š

ts
import { parseAbi } from 'viem'
import implAbi from '../abi/CrowdfundImplementation.json'
const ABI = parseAbi(implAbi as any) // or keep as JSON if you prefer
å°†äº‹ä»¶ç­¾åé›†ä¸­åœ¨ä¸€å¤„ï¼Œé¿å…å¤šå¤„æ‰‹å†™é‡å¤ï¼Œé™ä½ç»´æŠ¤æˆæœ¬ã€‚

éœ€è¦æˆ‘æŠŠä¸Šè¿° ABI æ–‡ä»¶è¿åŒè„šæœ¬ä¸€èµ·æ‰“åˆ°ä½  monorepo çš„å¯¹åº”ç›®å½•ï¼Œå¹¶é™„ä¸Šä¸€ä¸ª npm scriptï¼ˆå¦‚ "sync:abi"ï¼‰æ¥è‡ªåŠ¨ä» Foundry out ç›®å½•åŒæ­¥åˆ°å‰ç«¯å—ï¼Ÿ

1github.com
éœ€è¦ä½ æŠŠä¸Šè¿° ABI æ–‡ä»¶è¿åŒè„šæœ¬ä¸€èµ·æ‰“åˆ°ä½  monorepo çš„å¯¹åº”ç›®å½•ï¼Œå¹¶é™„ä¸Šä¸€ä¸ª npm scriptï¼ˆå¦‚ "sync:abi"ï¼‰æ¥è‡ªåŠ¨ä» Foundry out ç›®å½•åŒæ­¥åˆ°å‰ç«¯
æ˜ç™½äº†ï¼Œæˆ‘ä¼šç›´æ¥ç»™ä½ ä¸€ä¸ªå¯åˆå¹¶åˆ° monorepo çš„ç›®å½•ç»“æ„ + è„šæœ¬æ–¹æ¡ˆï¼Œè¿™æ ·ä½ åªè¦å¤åˆ¶è¿‡å»å°±èƒ½ç”¨ã€‚ æˆ‘ä¼šå‡è®¾ä½ çš„ monorepo ç»“æ„æ˜¯è¿™æ ·çš„ï¼ˆå¯æŒ‰éœ€è°ƒæ•´ï¼‰ï¼š

ä»£ç 
monorepo/
â”œâ”€â”€ contracts/                # Foundry åˆçº¦ç›®å½•
â”‚   â””â”€â”€ out/                  # forge build äº§ç‰©
â”œâ”€â”€ frontend/                 # Next.js / wagmi å‰ç«¯
â”‚   â””â”€â”€ abi/                  # å­˜æ”¾ ABI JSON
â”œâ”€â”€ scripts/                  # è‡ªå®šä¹‰è„šæœ¬
â””â”€â”€ package.json
1. å°† ABI æ–‡ä»¶æ”¾åˆ° frontend/abi
åœ¨ frontend/abi/ ä¸‹æ–°å»ºä¸‰ä¸ªæ–‡ä»¶ï¼š

CrowdfundImplementation.jsonï¼ˆæˆ‘ä¸Šé¢ç»™ä½ çš„å®Œæ•´ ABIï¼‰

CrowdfundFactory.json

GovernanceTimelockSample.json

2. æ–°å»ºåŒæ­¥è„šæœ¬
åœ¨ scripts/ ä¸‹æ–°å»º sync-abi.shï¼ˆè®°å¾—èµ‹äºˆå¯æ‰§è¡Œæƒé™ chmod +x scripts/sync-abi.shï¼‰ï¼š

bash
#!/usr/bin/env bash
set -e

# æ ¹ç›®å½•æ‰§è¡Œ
ROOT_DIR=$(cd "$(dirname "$0")/.." && pwd)

CONTRACTS_OUT="$ROOT_DIR/contracts/out"
FRONTEND_ABI="$ROOT_DIR/frontend/abi"

echo "ğŸ”„ Building contracts with Foundry..."
cd "$ROOT_DIR/contracts"
forge build

echo "ğŸ“¦ Syncing ABI files to frontend..."
cp "$CONTRACTS_OUT/CrowdfundImplementation.sol/CrowdfundImplementation.abi.json" \
   "$FRONTEND_ABI/CrowdfundImplementation.json"

cp "$CONTRACTS_OUT/CrowdfundFactory.sol/CrowdfundFactory.abi.json" \
   "$FRONTEND_ABI/CrowdfundFactory.json"

# å¦‚æœ GovernanceTimelock æ˜¯ä½ è‡ªå·±å†™çš„åˆçº¦ï¼Œä¹Ÿå¯ä»¥è‡ªåŠ¨å¤åˆ¶
# cp "$CONTRACTS_OUT/GovernanceTimelock.sol/GovernanceTimelock.abi.json" \
#    "$FRONTEND_ABI/GovernanceTimelock.json"

echo "âœ… ABI sync complete."
3. åœ¨ package.json æ·»åŠ  npm script
åœ¨ monorepo æ ¹ç›®å½•çš„ package.json ä¸­æ·»åŠ ï¼š

json
{
  "scripts": {
    "sync:abi": "bash scripts/sync-abi.sh"
  }
}
è¿™æ ·ä½ åªéœ€è¦æ‰§è¡Œï¼š

bash
npm run sync:abi
å°±ä¼šè‡ªåŠ¨ï¼š

forge build ç¼–è¯‘åˆçº¦

ä» contracts/out å¤åˆ¶æœ€æ–° ABI åˆ° frontend/abi

4. å¯é€‰å¢å¼º
è‡ªåŠ¨ç”Ÿæˆ TypeScript ç±»å‹ å¦‚æœä½ ç”¨ viem æˆ– typechainï¼Œå¯ä»¥åœ¨è„šæœ¬æœ«å°¾åŠ ï¼š

bash
echo "ğŸ›  Generating TypeScript types..."
pnpm typechain --target=viem --out-dir frontend/types 'frontend/abi/*.json'
å¤šåˆçº¦æ‰¹é‡åŒæ­¥ å¯ä»¥ç”¨ find éå† contracts/out ä¸‹çš„æ‰€æœ‰ .abi.jsonï¼ŒæŒ‰æ–‡ä»¶åå¤åˆ¶åˆ°å‰ç«¯ã€‚